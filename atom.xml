<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>进进吖</title>
  
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://yoursite.com/"/>
  <updated>2019-07-17T17:30:34.852Z</updated>
  <id>http://yoursite.com/</id>
  
  <author>
    <name>进进吖</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>JavaScript-this call、apply、bind</title>
    <link href="http://yoursite.com/2019/07/17/JavaScript-this%20call%E3%80%81apply%E3%80%81bind/"/>
    <id>http://yoursite.com/2019/07/17/JavaScript-this call、apply、bind/</id>
    <published>2019-07-17T15:52:44.093Z</published>
    <updated>2019-07-17T17:30:34.852Z</updated>
    
    <content type="html"><![CDATA[<h3 id="this指向"><a href="#this指向" class="headerlink" title="this指向"></a>this指向</h3><p><strong>this永远指向最后调用他的那个对象</strong></p><blockquote><p>一个函数执行前面没有调用他的对象 <strong>this指向的window</strong><br>匿名函数 自执行函数 函数当参数 <strong>默认指向window</strong><br>函数是否在 new中调用 xxx = new xxx <strong>this指向的实例</strong><br>元素事件中绑定函数的this是 <strong>绑定的元素</strong></p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">&apos;虽然将a.fn赋值给了变量f,但是没有调用，所以fn()最后仍然是被 window 调用的。</span><br><span class="line">所以 this 指向的也就是 window&apos; </span><br><span class="line">var name = &quot;windowsName&quot;;</span><br><span class="line">var a = &#123;</span><br><span class="line">    name : null,</span><br><span class="line">    fn : function () &#123;</span><br><span class="line">        console.log(this.name); &apos;windowsName&apos;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">var f = a.fn;</span><br><span class="line">&apos;变量f == fn这个函数本身&apos;</span><br><span class="line">f();</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">var a=1</span><br><span class="line">var obj=&#123;</span><br><span class="line">a:2,</span><br><span class="line">getA:function()&#123;return this.a&#125;</span><br><span class="line">&#125;</span><br><span class="line">console.log(obj.getA());  &apos;2 (this=&gt;obj)&apos;</span><br><span class="line">console.log(obj.getA.call());  &apos;1 (this=&gt;window)&apos;</span><br><span class="line">console.log(obj.getA.call(&#123;a:10&#125;));  &apos;10 (this=&gt;&#123;a:10&#125;) window&apos;</span><br></pre></td></tr></table></figure><p><strong>箭头函数中的this</strong></p><ul><li>箭头函数中的没有this指向,也没有arguments</li><li>箭头函数中的this始终指向 <strong>函数定义</strong> 时的this</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">var name = &quot;windowsName&quot;;</span><br><span class="line">var a = &#123;</span><br><span class="line">    name : &quot;Cherry&quot;,</span><br><span class="line">    func1: function () &#123;</span><br><span class="line">        console.log(this.name)     </span><br><span class="line">    &#125;,</span><br><span class="line">    func2: function () &#123;</span><br><span class="line">        setTimeout( () =&gt; &#123;</span><br><span class="line">            this.func1()</span><br><span class="line">        &#125;,100);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line">a.func2()</span><br></pre></td></tr></table></figure><h3 id="call-apply-bind"><a href="#call-apply-bind" class="headerlink" title="call apply bind"></a>call apply bind</h3><ul><li>相同点第一个参数都是改变this指向,第一个参数为null/undefined/为空,默认指向的window<blockquote><p>call 可以接收一个参数列表<br>apply接收的是一个类数组<br>bind需要执行一个()并且返回一个新的函数</p></blockquote></li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">&apos;call&apos;</span><br><span class="line">    var a = &#123;</span><br><span class="line">        name : &quot;Cherry&quot;,</span><br><span class="line">        func1: function () &#123;</span><br><span class="line">            console.log(this.name)</span><br><span class="line">        &#125;,</span><br><span class="line">        func2: function () &#123;</span><br><span class="line">            setTimeout(  function () &#123;</span><br><span class="line">                this.func1()</span><br><span class="line">            &#125;.call(a),100);  &apos;apply(同理)&apos;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line">    a.func2()   &apos;Cherry&apos;</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">&apos;bind 是创建一个新函数,需要执行一下&apos;</span><br><span class="line">    var a =&#123;</span><br><span class="line">        name : &quot;Cherry&quot;,</span><br><span class="line">        fn : function (a,b) &#123;</span><br><span class="line">            console.log( a + b)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    var b = a.fn;</span><br><span class="line">    b.bind(a,1,2)() &apos;3&apos;</span><br><span class="line"></span><br><span class="line">&apos;bind 方法实现&apos;</span><br><span class="line"> Function.prototype.bind = function(context,...arg)&#123;</span><br><span class="line">     return ()=&gt;&#123;this.apply(context,arg)&#125;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure><h3 id="new-构造函数"><a href="#new-构造函数" class="headerlink" title="new 构造函数"></a>new 构造函数</h3><ul><li>函数调用前使用了new关键字,调用了构造函数,看似创建了新的函数,实际上是函数重新创建了对象</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">function myFunction(arg1, arg2) &#123;</span><br><span class="line">    this.firstName = arg1;</span><br><span class="line">    this.lastName  = arg2;</span><br><span class="line">&#125;</span><br><span class="line">&apos;This    creates a new object&apos;</span><br><span class="line">var a = new myFunction(&quot;Li&quot;,&quot;Cherry&quot;);</span><br><span class="line">a.lastName;</span><br></pre></td></tr></table></figure><h3 id="new-的原理"><a href="#new-的原理" class="headerlink" title="new 的原理"></a>new 的原理</h3><ul><li>创建一个新的对象</li><li>这个新对象会被执行[原型]连接</li><li>属性和方法都会加入到<strong>this</strong>引用的对象中,并执行构造函数中的方法</li><li>如果函数中没有返回其他对象，那么this就指向了这个新对象<br>否则this就指向了构造函数中返回的对象</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">&apos;var obj = new fn()&apos;</span><br><span class="line">function new(fn)&#123;</span><br><span class="line">    let obj = &#123;&#125;;</span><br><span class="line">    obj.__propo__ = fn.propotype;</span><br><span class="line">    let res = fn.call(obj);</span><br><span class="line">    if (typeof(res)==&apos;object&apos; || typeof(res)== &apos;function&apos;)&#123;</span><br><span class="line">        return res</span><br><span class="line">    &#125;</span><br><span class="line">    return obj;</span><br><span class="line">&#125;</span><br><span class="line">&apos;例子&apos;:</span><br><span class="line">function Student(name, num, age) &#123;</span><br><span class="line">            this.name = name;</span><br><span class="line">            this.num = num;</span><br><span class="line">            this.age = age;</span><br><span class="line">            let obj = &#123;man:&apos;男&apos;&#125;;</span><br><span class="line">            &apos;否则this指向构造函数中返回的对象&apos;</span><br><span class="line">            return obj;</span><br><span class="line">        &#125;</span><br><span class="line">        &apos;如果函数没有返回其他对象，那么this指向这个新对象 == s2&apos;</span><br><span class="line">        var s2 = new Student(&quot;xiaoming&quot;, 54321, 18)</span><br><span class="line">        console.log(s2);</span><br></pre></td></tr></table></figure><h3 id="通过new的方式创建对象和通过字面量创建有什么区别？"><a href="#通过new的方式创建对象和通过字面量创建有什么区别？" class="headerlink" title="通过new的方式创建对象和通过字面量创建有什么区别？"></a>通过new的方式创建对象和通过字面量创建有什么区别？</h3><blockquote><p>字面量创建方式,简介且性能好<br>通过new的方式创建对象、本质上的方法是调用，其实是通过propo进行查找<br>查找过程中必将调用必须的堆栈信息,方法调用后(释放堆栈),造成一定的性能损耗</p></blockquote>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;this指向&quot;&gt;&lt;a href=&quot;#this指向&quot; class=&quot;headerlink&quot; title=&quot;this指向&quot;&gt;&lt;/a&gt;this指向&lt;/h3&gt;&lt;p&gt;&lt;strong&gt;this永远指向最后调用他的那个对象&lt;/strong&gt;&lt;/p&gt;
&lt;blockquote&gt;
&lt;
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>JavaScript-prototype</title>
    <link href="http://yoursite.com/2019/07/16/JavaScript-prototype/"/>
    <id>http://yoursite.com/2019/07/16/JavaScript-prototype/</id>
    <published>2019-07-16T15:39:01.010Z</published>
    <updated>2019-07-16T16:26:24.411Z</updated>
    
    <content type="html"><![CDATA[<h3 id="基于原型的理解"><a href="#基于原型的理解" class="headerlink" title="基于原型的理解"></a>基于原型的理解</h3><p> <strong>每个函数天生都自带一个属性prototype,这个属性是个对象</strong><br> <strong>这个对象储存了当前类提供给实例的公共属性和方法，浏览器默认给他开辟一个堆内存</strong><br> <strong>prototype都有一个默认属性，construction指向当前函数本身</strong><br> <strong>每个对象都有一个<strong>propo</strong>这个属性，这个属性指向的是当前所属类的prototype</strong><br> <strong>如何不确定是谁的实例，那就是Object的实例</strong></p><h3 id="原型链"><a href="#原型链" class="headerlink" title="原型链"></a>原型链</h3><p> <strong>原型链是基于<strong>propo</strong>向上查找的机制，当我们去操作实例的某个属性和方法的时候，首先查找自己的空间下有没有这个属性，如果有的话就用自己的，如果没有的话就通过<strong>propo</strong>机制向上查找所属类的prototype，如果找到就用找到的，如果没有找到则依次查找，一直找到Object.prototype为止，如果还没有找到，则返回undefined</strong></p> <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Object.__proto__  === Function.prototype;</span><br><span class="line">Function.prototype.__proto__ === Object.prototype;</span><br><span class="line">Object.prototype.__proto__ === null;</span><br></pre></td></tr></table></figure><p> <strong>实例于与构造函数的关系图</strong></p><p> <img src="https://user-gold-cdn.xitu.io/2019/4/8/169fc27e0cf46ee9?imageView2/0/w/1280/h/960/format/webp/ignore-error/1" alt="实例与构造函数"><span class="img-alt">实例与构造函数</span></p><p> <strong>prototype与propo的关系</strong></p><blockquote><p>propo 是每个实例都有的属性，指向的当前类所属的原型<br>实例的 propo 与其构造函数中的 prototype 指向的同一个对象</p></blockquote> <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">function Student(name) &#123;</span><br><span class="line">    this.name = name;</span><br><span class="line">&#125;</span><br><span class="line">Student.prototype.setAge = function ()&#123;</span><br><span class="line">    this.age=20;</span><br><span class="line">&#125;</span><br><span class="line">let Jack = new Student(&apos;jack&apos;);</span><br><span class="line">console.log(Jack.__proto__);</span><br><span class="line">console.log(Student.prototype);</span><br><span class="line">console.log(Jack.__proto__ instanceof Student.prototype); &apos;true&apos;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;基于原型的理解&quot;&gt;&lt;a href=&quot;#基于原型的理解&quot; class=&quot;headerlink&quot; title=&quot;基于原型的理解&quot;&gt;&lt;/a&gt;基于原型的理解&lt;/h3&gt;&lt;p&gt; &lt;strong&gt;每个函数天生都自带一个属性prototype,这个属性是个对象&lt;/strong&gt;&lt;
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>JavaScript-变量提升</title>
    <link href="http://yoursite.com/2019/07/16/JavaScript-%E5%8F%98%E9%87%8F%E6%8F%90%E5%8D%87/"/>
    <id>http://yoursite.com/2019/07/16/JavaScript-变量提升/</id>
    <published>2019-07-15T16:09:03.477Z</published>
    <updated>2019-07-16T15:37:25.537Z</updated>
    
    <content type="html"><![CDATA[<h4 id="let-var-const"><a href="#let-var-const" class="headerlink" title="let var const"></a>let var const</h4><p> <strong>let const两者都没有变量提升,而var存在变量提升</strong><br> <strong>let const 存在块级作用域</strong><br> <strong>两者都不存在重复声明,const一旦声明必须赋值，一旦赋值不能更改</strong><br> <strong>let 和 const如果提前声明，会报错（暂时性死区）</strong></p><h4 id="js中的变量提升"><a href="#js中的变量提升" class="headerlink" title="js中的变量提升"></a>js中的变量提升</h4><p> <strong>变量提升就是:在变量提升之前使用了该变量，结果是undefined</strong></p><blockquote><p>当作用域形成之后,浏览器会把带var(声明)，function(声明并定义)关键字的进行声明和定义<br>声明：var a/function sum() 默认值是undefined 定义：就是赋值<br>变量提升只存在于当前作用域，当页面刚加载时会对全局作用域下的变量进行变量提升，函数中存储的都是字符串<br>浏览器很懒，当代码执行遇到创建函数，变量声明这个阶段时，直接回跳过(变量提升过程中已完成)</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">&apos;test函数内部有变量申明var a;会提升到函数作用域的最前面</span><br><span class="line">全局没有变量a,所以结果是undefined而不会报错&apos;</span><br><span class="line">   function test()&#123;</span><br><span class="line">        if(&apos;a&apos; in window)&#123;</span><br><span class="line">            var a = 10;</span><br><span class="line">        &#125;</span><br><span class="line">        console.log(a); </span><br><span class="line">    &#125;</span><br><span class="line">    test();</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"> &apos;这里foo为undefined,所以!foo结果为true;&apos;</span><br><span class="line">var foo = 1;</span><br><span class="line">function bar() &#123;</span><br><span class="line">    if(!foo)</span><br><span class="line">    &#123;</span><br><span class="line">        var foo = 10;</span><br><span class="line">    &#125;</span><br><span class="line">    console.log(foo); </span><br><span class="line">&#125;</span><br><span class="line">bar(); &apos;10&apos;</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">  &apos;变量提升a和b为undefined,虽然为undefined但是存在于window上,取反为false&apos;</span><br><span class="line"> var a=1</span><br><span class="line">if (!(b in window)) &#123;</span><br><span class="line">    var b=2;</span><br><span class="line">    a+=1; </span><br><span class="line">&#125;else&#123;</span><br><span class="line">    a+=2</span><br><span class="line">&#125;</span><br><span class="line">console.log(a); &apos;3&apos;</span><br><span class="line">console.log(b); &apos;undefined&apos;</span><br></pre></td></tr></table></figure><h4 id="js中暂时性死区？"><a href="#js中暂时性死区？" class="headerlink" title="js中暂时性死区？"></a>js中暂时性死区？</h4><p>暂时性死区的本质:当进入作用域时，所需要的变量已经存在，但是不可获取<br>只有等到声明的那一行代码出现，才可以获取和使用该变量。</p><p><em>闭包及其优点:</em></p><p>简单理解: <strong>闭包就是能够读取其他函数中变量的函数</strong></p><blockquote><p>保护函数中的私有变量不受外界变量的干扰<br>实现了js的模块化<br>模仿块级作用域(Es5不存在块级作用域)<br>缺点：大量使用闭包，会造成性能消耗</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">函数A中包含了函数B,函数B中使用了函数A的变量,&apos;函数B则是闭包&apos;</span><br><span class="line">function A()&#123;</span><br><span class="line">    let a = 1;</span><br><span class="line">    function B()&#123;</span><br><span class="line">        console.log(a)</span><br><span class="line">    &#125;</span><br><span class="line">    return B()</span><br><span class="line">&#125;</span><br><span class="line">A()</span><br></pre></td></tr></table></figure><p>面试题</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&apos;利用let的块级作用域，让每一次的值形成唯一&apos;</span><br><span class="line">for ( let i=0; i&lt;=5; i++) &#123;</span><br><span class="line">setTimeout( function timer() &#123;</span><br><span class="line">console.log( i );</span><br><span class="line">&#125;, i*1000 );</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&apos;利用定时器的第二个参数&apos;</span><br><span class="line">for ( var i=0; i&lt;=5; i++) &#123;</span><br><span class="line">setTimeout( function timer(i) &#123;</span><br><span class="line">console.log( i );</span><br><span class="line">&#125;, i*1000,i);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&apos;利用闭包&apos;</span><br><span class="line">for ( var i=0; i&lt;=5; i++) &#123;</span><br><span class="line">(function(i)&#123;</span><br><span class="line">        setTimeout( ()=&gt;&#123;</span><br><span class="line">console.log( i );</span><br><span class="line">&#125;,i*1000);</span><br><span class="line">    &#125;)(i)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h4 id=&quot;let-var-const&quot;&gt;&lt;a href=&quot;#let-var-const&quot; class=&quot;headerlink&quot; title=&quot;let var const&quot;&gt;&lt;/a&gt;let var const&lt;/h4&gt;&lt;p&gt; &lt;strong&gt;let const两者都没有变量提
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>Html-css</title>
    <link href="http://yoursite.com/2019/07/14/html-Css/"/>
    <id>http://yoursite.com/2019/07/14/html-Css/</id>
    <published>2019-07-14T14:58:12.373Z</published>
    <updated>2019-07-14T15:48:04.126Z</updated>
    
    <content type="html"><![CDATA[<h3 id="HTML"><a href="#HTML" class="headerlink" title="HTML"></a>HTML</h3><h4 id="1-什么是标签语义化及其优点"><a href="#1-什么是标签语义化及其优点" class="headerlink" title="1.什么是标签语义化及其优点"></a>1.什么是标签语义化及其优点</h4><p>合理的标签做合理的事情<br><strong>优点:</strong></p><p>便于浏览器、搜索引擎的解析<br>便于阅读源代码的人对网站进行维护和理解<br>在没有css的情况下，页面的内容结构和代码结构更加美观</p><h4 id="2-H5中的新标签"><a href="#2-H5中的新标签" class="headerlink" title="2.H5中的新标签"></a>2.H5中的新标签</h4><p>1 <header>头部</header> <footer>尾部</footer><br>2 <nav>导航</nav> <cavas>动画</cavas><br>3 <audio>音频</audio> <video>视频</video></p><h4 id="3-本地存储方式"><a href="#3-本地存储方式" class="headerlink" title="3.本地存储方式"></a>3.本地存储方式</h4><p><strong>cookies: 存储浏览器端的数据，可以设置cookie的到期时间,如果不设置时间,则在浏览器关闭时关闭</strong><br><strong>session: 存储服务端的数据,session存储特定的用户回话所需要的属性和配置信息</strong></p><p><strong>两者的区别:</strong></p><blockquote><p>cookies 存储于浏览器端的数据，sessions存储于服务端的数据<br>cookies 安全性较低，cookies存储的信息为4k<br>session存储重要信息,如果sessions存储的信息过大，会占用服务器的性能</p></blockquote><p><strong>localStoage 本地存储方式 (永久) 除非主动清除,否则一直存在</strong><br><strong>sessionStorage 本地存储方式 (临时) 浏览器窗口关闭,则失效</strong></p><blockquote><p>1.localStoage.getItem(‘name’) ‘获取’ name 的值<br>2.localStoage.setItem(‘name’) ‘设置’ name 的值<br>3.localStoage.removeItem(‘name’) ‘删除’ name 的值</p></blockquote><h4 id="CSS"><a href="#CSS" class="headerlink" title="CSS"></a>CSS</h4><p><strong>css 盒模型</strong></p><p>box-sizing:border-box<br>box-sezing:content-box<br><strong>两者的区别:</strong></p><p>  1 border-box: 整个盒子的宽、高、包括 ‘margin’ ‘padding’ ‘border’<br>  2 content-box: 整个盒子的宽、高、’不包含’上面的元素</p><p><img src="https://user-gold-cdn.xitu.io/2019/3/17/1698bdd0101065ad?imageView2/0/w/1280/h/960/format/webp/ignore-error/1" alt="css 盒模型"><span class="img-alt">css 盒模型</span></p><p><strong>css 常用选择器</strong></p><blockquote><p>1.通配符：*<br>2.ID 选择器：#ID<br>3.类选择器：.class<br>4.元素选择器：p、a 等……<br>5.后代选择器：p span、div a 等……<br>6.伪类选择器：a:hover 等……<br>7.属性选择器：input[type=”text”] 等……<br>8.子元素选择器：li:firth-child、p:nth-child(1)</p></blockquote><p><strong>css 选择器的权重</strong></p><p><strong><em>1 ‘!important -&gt; 行内样式 -&gt; #id -&gt; .class -&gt; 元素和伪元素 -&gt; * -&gt; 继承 -&gt; 默认’</em></strong></p><p><strong>css 新特性</strong></p><blockquote><p>1.transition：过渡<br>2.transform：旋转、缩放、移动或者倾斜<br>3.animation：动画<br>4.gradient：渐变<br>5.shadow：阴影<br>6.border-radius：圆角<br>7.css 引入方式以及优先级</p></blockquote><p><strong><em>在引用 CSS 上，分为四种形式：行内样式、内嵌式、链接式以及导入式</em></strong></p><p><strong><em>在优先级上,行内样式 &gt; 链接式 &gt; 内嵌式 &gt; @import 导入式。</em></strong></p><p><strong>less 与 sass stylus 的区别</strong></p><p><strong><em>变量声明 :</em></strong></p><blockquote><p>1.Sass声明变量方式 $ 开头, 后面紧跟着变量值和变量名,变量名和变量值需要使用冒号:分隔开<br>2.Less 声明变量方式 @ 开头, 其余等同于Sass<br>3.stylus 变量声明没有任何限定,结尾分号可有可无, 变量名和变量值中间必须用 = 等号</p></blockquote><p><strong>作用域</strong></p><blockquote><p>Sass 作用域最差,不存在全局变量的概念, 注意相同的变量名字<br>Less 近期更新, 可以定义全局变量<br>与 Sass 相同,变量值输出是根据最近声明的一次定义,每次引用最近的定义</p></blockquote><p><strong>嵌套</strong></p><p><strong><em>三种都有设计嵌套关系,使用上没有任何区别,引用父级选择器的标记 &amp; 也相同</em></strong></p><p><strong>继承</strong></p><p><strong><em>Sass 和 Stylus 相似,能把一个选择器上的内容继承到另一个选择器上,使用『@extend』开始,后面接被继承的选择器</em></strong></p><p><strong>导入 import</strong></p><blockquote><p>‘Sass 中只存在使用 url() 表达式 引入式进行变量插值’<br>$device: mobile;<br>@import url(styles.#{$device}.css);</p></blockquote><blockquote><p>‘Less 可以在字符串中插值’<br>@device: mobile;<br>@import “styles.@{device}.css”;</p></blockquote><p><strong><em>‘Stylus 只能利用字符串拼接实现’</em></strong></p><blockquote><p>device = “mobile”<br>@import “styles.” + device + “.css”<br>Sass 和 less 语法相对于严谨,Stylus相对于自由,less表现方式更像是css,上手比较容易<br>Sass 和 stylus 具有逻辑处理方式 例如: 条件/循环 less需要通过when进行处理</p></blockquote>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;HTML&quot;&gt;&lt;a href=&quot;#HTML&quot; class=&quot;headerlink&quot; title=&quot;HTML&quot;&gt;&lt;/a&gt;HTML&lt;/h3&gt;&lt;h4 id=&quot;1-什么是标签语义化及其优点&quot;&gt;&lt;a href=&quot;#1-什么是标签语义化及其优点&quot; class=&quot;headerli
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>Hello World</title>
    <link href="http://yoursite.com/2019/07/13/hello-world/"/>
    <id>http://yoursite.com/2019/07/13/hello-world/</id>
    <published>2019-07-13T13:10:09.898Z</published>
    <updated>2019-07-13T13:10:09.898Z</updated>
    
    <content type="html"><![CDATA[<p>Welcome to <a href="https://hexo.io/" target="_blank" rel="noopener">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/" target="_blank" rel="noopener">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html" target="_blank" rel="noopener">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues" target="_blank" rel="noopener">GitHub</a>.</p><h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo new <span class="string">"My New Post"</span></span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/writing.html" target="_blank" rel="noopener">Writing</a></p><h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/server.html" target="_blank" rel="noopener">Server</a></p><h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/generating.html" target="_blank" rel="noopener">Generating</a></p><h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/deployment.html" target="_blank" rel="noopener">Deployment</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;Welcome to &lt;a href=&quot;https://hexo.io/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;Hexo&lt;/a&gt;! This is your very first post. Check &lt;a href=&quot;https://hexo.
      
    
    </summary>
    
    
  </entry>
  
</feed>
