<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>进进吖</title>
  
  
  <link href="http://yoursite.com/atom.xml" rel="self"/>
  
  <link href="http://yoursite.com/"/>
  <updated>2022-11-17T09:05:19.009Z</updated>
  <id>http://yoursite.com/</id>
  
  <author>
    <name>进进吖</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>vuex原理解析</title>
    <link href="http://yoursite.com/2022/10/08/vuex%E5%8E%9F%E7%90%86%E8%A7%A3%E6%9E%90/"/>
    <id>http://yoursite.com/2022/10/08/vuex%E5%8E%9F%E7%90%86%E8%A7%A3%E6%9E%90/</id>
    <published>2022-10-08T13:25:55.919Z</published>
    <updated>2022-11-17T09:05:19.009Z</updated>
    
    <content type="html"><![CDATA[<h3 id="核心（个人理解）"><a href="#核心（个人理解）" class="headerlink" title="核心（个人理解）"></a>核心（个人理解）</h3><blockquote><p>1、Vuex 本质是一个对象<br>2、Vuex 对象有两个属性，一个是 install 方法，一个是 Store 类<br>3、install 的作用是将 store 这个实例挂载到所有的组件上<br>4、Store 类包含 commit、dispatch 这些方法，Store 类中将 state 包装成 data，作为 new vue 的 <strong>参数</strong>，从而实现响应式</p></blockquote><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">new Vue(&#123;</span><br><span class="line">  store,</span><br><span class="line">  render: h =&gt; h(App)</span><br><span class="line">&#125;).$mount(&#x27;#app&#x27;)</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="剖析-Vuex-本质"><a href="#剖析-Vuex-本质" class="headerlink" title="剖析 Vuex 本质"></a>剖析 Vuex 本质</h3><blockquote><p>import Vuex from ‘vuex’<br>先 var store &#x3D; new Vuex.Store({…}),再把 store 作为参数的一个属性值，new Vue({store})<br>通过 Vue.use(Vuex) 使得每个组件都可以拥有 store 实例</p></blockquote><p>通过上述引入过程可以发现：<br>new Vuex.store({})获得一个 store 实例，在引入的 Vuex 中有 Store 这个类最为 Vuex 中的一个属性<br>因为通过 import 引入的，<strong>实质上就是一个导出一个对象的引用</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">class Store &#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">let install = function()&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">let Vuex = &#123;</span><br><span class="line">  Store,</span><br><span class="line">  install</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="分析-vue-use"><a href="#分析-vue-use" class="headerlink" title="分析 vue.use();"></a>分析 vue.use();</h3><p><strong>Vue.use(plugin);</strong></p><blockquote><p>1、参数为 {Object | Function} plugin;<br>2、用法<br>(1) 安装 vue.js 插件 如果插件是一个对象，那么他内部必须要有一个 install 方法<br>如果插件是一个函数,它会被作为 install 方法，调用 install 方法时，会将 Vue 作为参数传入<br>install 如果被同一个插件调用多次，插件也只会安装一次<br>3、源码实现及个人理解</p></blockquote><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">Vue.use = function(plugin)&#123;</span><br><span class="line">  const installplugin = (this._installplugin || (this._installedPlugins = []));</span><br><span class="line"></span><br><span class="line">  if(installplugin.indexOf(plugin)&gt;-1)&#123;</span><br><span class="line">    return this</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  const args = Array.from(arguments,1);</span><br><span class="line">  args.unshift(this);</span><br><span class="line">  if(typeof plugin.install === &#x27;function&#x27;)&#123;</span><br><span class="line">plugin.install.apply(plugin,args);</span><br><span class="line">&#125;else if(typeof plugin === &#x27;function&#x27;)&#123;</span><br><span class="line">plugin.apply(null,plugin,args);</span><br><span class="line">&#125;</span><br><span class="line">installedPlugins.push(plugin);</span><br><span class="line">return this;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><blockquote><p>1.在Vue.js上新增了use方法，并接收一个参数plugin。<br>2.首先判断插件是不是已经别注册过，如果被注册过，则直接终止方法执行。<br>3、Array.from方法我们在就是将类数组转成真正的数组。使用Array.from方法得到arguments。除了第一个参数之外，剩余的所有参数将得到的列表赋值给args，然后将Vue添加到args列表的最前面。这样做的目的是保证install方法被执行时第一个参数是Vue，其余参数是注册插件时传入的参数。<br>4、由于plugin参数支持对象和函数类型，所以通过判断plugin.install和plugin哪个是函数，即可知用户使用哪种方式祖册的插件，然后执行用户编写的插件并将args作为参数传入。<br>5、将插件添加到installedPlugins中，保证相同的插件不会反复被注册。</p></blockquote><h3 id="install方法"><a href="#install方法" class="headerlink" title="install方法"></a>install方法</h3><blockquote><p>mixin的作用是将mixin的内容混合到Vue的初始参数options中。<br>如果是在created操作的话，$options已经初始化好了。<br>如果判断当前组件是根组件的话，就将我们传入的store挂在到根组件实例上，属性名为$store。<br>如果判断当前组件是子组件的话，就将我们根组件的$store也复制给子组件。注意是引用的复制，因此每个组件都拥有了同一个$store挂载在它身上。</p></blockquote><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">let install = function(Vue)&#123;</span><br><span class="line">    Vue.mixin(&#123;</span><br><span class="line">        beforeCreate()&#123;</span><br><span class="line">            if (this.$options &amp;&amp; this.$options.store)&#123;</span><br><span class="line">                this.$store = this.$options.store</span><br><span class="line">            &#125;else &#123;</span><br><span class="line">                this.$store = this.$parent &amp;&amp; this.$parent.$store</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="实现Vuex的state"><a href="#实现Vuex的state" class="headerlink" title="实现Vuex的state"></a>实现Vuex的state</h3><blockquote><p>初始化项目时是以下状态，其实也就是说，将这个对象当作参数了。</p></blockquote><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">export default new Vuex.Store(&#123;</span><br><span class="line">  state: &#123;</span><br><span class="line">    num:0</span><br><span class="line">  &#125;,</span><br><span class="line">  mutations: &#123;</span><br><span class="line">  &#125;,</span><br><span class="line">  actions: &#123;</span><br><span class="line">  &#125;,</span><br><span class="line">  modules: &#123;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br><span class="line"></span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">class Store&#123;</span><br><span class="line">    constructor(options)&#123;</span><br><span class="line">        this.state = options.state || &#123;&#125;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>知识点：Vuex和全局变量有什么区别，state里的为是响应式！<br>new Vue（）的时候，传入的data是响应式的</p></blockquote><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">class Store&#123;</span><br><span class="line">    constructor(options) &#123;</span><br><span class="line">        this.vm = new Vue(&#123;</span><br><span class="line">            data:&#123;</span><br><span class="line">                state:options.state</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="实现getter"><a href="#实现getter" class="headerlink" title="实现getter"></a>实现getter</h3><blockquote><p>原理则利用了vue2中的Object.defineProperty的get方法</p></blockquote><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">class Store&#123;</span><br><span class="line"></span><br><span class="line">    constructor(options) &#123;</span><br><span class="line">        this.vm = new Vue(&#123;</span><br><span class="line">            data:&#123;</span><br><span class="line">                state:options.state</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;)</span><br><span class="line"></span><br><span class="line">        let getters = options.getter || &#123;&#125;</span><br><span class="line">        this.getters = &#123;&#125;</span><br><span class="line">        Object.keys(getters).forEach(getterName=&gt;&#123;</span><br><span class="line">            Object.defineProperty(this.getters,getterName,&#123;</span><br><span class="line">                get:()=&gt;&#123;</span><br><span class="line">                    return getters[getterName](this.state)</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;)</span><br><span class="line">        &#125;)</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    get state()&#123;</span><br><span class="line">        return this.vm.state</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="实现mutation"><a href="#实现mutation" class="headerlink" title="实现mutation"></a>实现mutation</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line">class Store&#123;</span><br><span class="line">    constructor(options) &#123;</span><br><span class="line">        this.vm = new Vue(&#123;</span><br><span class="line">            data:&#123;</span><br><span class="line">                state:options.state</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;)</span><br><span class="line"></span><br><span class="line">        let getters = options.getter || &#123;&#125;</span><br><span class="line">        this.getters = &#123;&#125;</span><br><span class="line">        Object.keys(getters).forEach(getterName=&gt;&#123;</span><br><span class="line">            Object.defineProperty(this.getters,getterName,&#123;</span><br><span class="line">                get:()=&gt;&#123;</span><br><span class="line">                    return getters[getterName](this.state)</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;)</span><br><span class="line">        &#125;)</span><br><span class="line">        </span><br><span class="line">        let mutations = options.mutations || &#123;&#125;</span><br><span class="line">        this.mutations = &#123;&#125;</span><br><span class="line">        Object.keys(mutations).forEach(mutationName=&gt;&#123;</span><br><span class="line">            this.mutations[mutationName] =  (arg)=&gt; &#123;</span><br><span class="line">                mutations[mutationName](this.state,arg)</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;)</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    commit(method,arg)&#123;</span><br><span class="line">        this.mutations[method](arg)</span><br><span class="line">    &#125;</span><br><span class="line">    get state()&#123;</span><br><span class="line">        return this.vm.state</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="实现actions"><a href="#实现actions" class="headerlink" title="实现actions"></a>实现actions</h3><blockquote><p>1.commit必须修改为箭头函数或者bind修改this（this指向问题）</p></blockquote><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">actions: &#123;</span><br><span class="line">    asyncIncre(&#123;commit&#125;,arg)&#123;</span><br><span class="line">        setTimeout(()=&gt;&#123;</span><br><span class="line">          commit(&#x27;xxx&#x27;,arg)</span><br><span class="line">        &#125;,1000)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;,</span><br><span class="line"></span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line">class Store&#123;</span><br><span class="line">    constructor(options) &#123;</span><br><span class="line">        this.vm = new Vue(&#123;</span><br><span class="line">            data:&#123;</span><br><span class="line">                state:options.state</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;)</span><br><span class="line"></span><br><span class="line">        let getters = options.getter || &#123;&#125;</span><br><span class="line">        this.getters = &#123;&#125;</span><br><span class="line">        Object.keys(getters).forEach(getterName=&gt;&#123;</span><br><span class="line">            Object.defineProperty(this.getters,getterName,&#123;</span><br><span class="line">                get:()=&gt;&#123;</span><br><span class="line">                    return getters[getterName](this.state)</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;)</span><br><span class="line">        &#125;)</span><br><span class="line"></span><br><span class="line">        let mutations = options.mutations || &#123;&#125;</span><br><span class="line">        this.mutations = &#123;&#125;</span><br><span class="line">        Object.keys(mutations).forEach(mutationName=&gt;&#123;</span><br><span class="line">            this.mutations[mutationName] =  (arg)=&gt; &#123;</span><br><span class="line">                mutations[mutationName](this.state,arg)</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;)</span><br><span class="line"></span><br><span class="line">        let actions = options.actions</span><br><span class="line">        this.actions = &#123;&#125;</span><br><span class="line">        Object.keys(actions).forEach(actionName=&gt;&#123;</span><br><span class="line">            this.actions[actionName] = (arg)=&gt;&#123;</span><br><span class="line">                actions[actionName](this,arg)</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;)</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    dispatch(method,arg)&#123;</span><br><span class="line">        this.actions[method](arg)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    commit=(method,arg)=&gt;&#123;</span><br><span class="line">        console.log(method);</span><br><span class="line">        console.log(this.mutations);</span><br><span class="line">        this.mutations[method](arg)</span><br><span class="line">    &#125;</span><br><span class="line">    get state()&#123;</span><br><span class="line">        return this.vm.state</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h3 id=&quot;核心（个人理解）&quot;&gt;&lt;a href=&quot;#核心（个人理解）&quot; class=&quot;headerlink&quot; title=&quot;核心（个人理解）&quot;&gt;&lt;/a&gt;核心（个人理解）&lt;/h3&gt;&lt;blockquote&gt;
&lt;p&gt;1、Vuex 本质是一个对象&lt;br&gt;2、Vuex 对象有两个属性，</summary>
      
    
    
    
    <category term="vue" scheme="http://yoursite.com/categories/vue/"/>
    
    
  </entry>
  
  <entry>
    <title>vue-router(原理解析)</title>
    <link href="http://yoursite.com/2020/12/11/vueRouter%E5%8E%9F%E7%90%86%E8%A7%A3%E6%9E%90/"/>
    <id>http://yoursite.com/2020/12/11/vueRouter%E5%8E%9F%E7%90%86%E8%A7%A3%E6%9E%90/</id>
    <published>2020-12-11T06:00:45.257Z</published>
    <updated>2020-12-16T15:51:02.351Z</updated>
    
    <content type="html"><![CDATA[<h3 id="前端路由实现的两种方式"><a href="#前端路由实现的两种方式" class="headerlink" title="前端路由实现的两种方式"></a>前端路由实现的两种方式</h3><blockquote><p>hash、history<br>目前vue是spa应用，路径切换可以重新渲染组件（也刷新页面）<br>hash的优缺点 样式丑、兼容性好、不需要服务端支持<br>模拟实现方法 window.location.hash &#x3D; ‘xx’、 事件监听方法是 window.addEventListener(hashchang);<br>history的优缺点 样式美观、兼容性差、需要服务端支持<br>模拟实现方法 window.history.pushState({数据},’标题’,’路径’)  事件监听方法是 window.addEventListener(‘popState’);</p></blockquote><h3 id="Vue-use-是什么？干了那些事情？"><a href="#Vue-use-是什么？干了那些事情？" class="headerlink" title="Vue.use()是什么？干了那些事情？"></a>Vue.use()是什么？干了那些事情？</h3><blockquote><p>Vue.use(vueRouter);<br>plugin 插件<br>options 参数<br>this 指向的是当前的 Vue</p></blockquote><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Vue.use = function(plugin,options)&#123; </span><br><span class="line">    plugin.install(this,options)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h3 id=&quot;前端路由实现的两种方式&quot;&gt;&lt;a href=&quot;#前端路由实现的两种方式&quot; class=&quot;headerlink&quot; title=&quot;前端路由实现的两种方式&quot;&gt;&lt;/a&gt;前端路由实现的两种方式&lt;/h3&gt;&lt;blockquote&gt;
&lt;p&gt;hash、history&lt;br&gt;目前vue</summary>
      
    
    
    
    <category term="vue" scheme="http://yoursite.com/categories/vue/"/>
    
    
  </entry>
  
  <entry>
    <title>计算机网络 - HTTP</title>
    <link href="http://yoursite.com/2020/12/02/HTTP/"/>
    <id>http://yoursite.com/2020/12/02/HTTP/</id>
    <published>2020-12-02T04:15:13.613Z</published>
    <updated>2020-12-16T16:04:53.018Z</updated>
    
    <content type="html"><![CDATA[<h3 id="HTTP-7层协议"><a href="#HTTP-7层协议" class="headerlink" title="HTTP 7层协议"></a>HTTP 7层协议</h3><blockquote><p>7 应用层 例如：(<strong>DNS和HTTP</strong>)<br>6 表示层 主要功能：转换，压缩和加密。<br>5 会话层 可以把“会话”理解为两个应用程序进程之间的逻辑连接，两个应用程序通过这个逻辑连接在一段时间内交换数据。会话层的作用就是为创建、管理和终止会话提供必要的方法<br>4 传输层 例如：<strong>TCP</strong> 提供数据传输的服务<br>3网络层 例如：<strong>IP</strong>、地址、路由、分段和重组<br>2 数据链路层 例如：<strong>以太网</strong>、令牌环、HDLC、帧中继、ISDN、ATM、IEEE 802.11、FDDI、PPP<br>1 物理层 例如：线路、无线电、光纤、信鸽</p></blockquote><h3 id="HTTP-发展史"><a href="#HTTP-发展史" class="headerlink" title="HTTP 发展史"></a>HTTP 发展史</h3><h4 id="HTTP-x2F-0-9"><a href="#HTTP-x2F-0-9" class="headerlink" title="HTTP&#x2F;0.9"></a>HTTP&#x2F;0.9</h4><blockquote><p>Http 0.9 只是传输体积很小的文件, <strong>没有http请求体和请求头</strong> ,服务器也不返回头信息;</p></blockquote><h4 id="HTTP-x2F-1-0"><a href="#HTTP-x2F-1-0" class="headerlink" title="HTTP&#x2F;1.0"></a>HTTP&#x2F;1.0</h4><blockquote><p>Http 1.0 加入了请求头和响应头、支持多种多种请求类型、状态码、用户代理、Cache 机制<br>GET POST HEAD</p></blockquote><h4 id="HTTP-x2F-1-1"><a href="#HTTP-x2F-1-1" class="headerlink" title="HTTP&#x2F;1.1"></a>HTTP&#x2F;1.1</h4><blockquote><p>改进了http1.0<strong>每次HTTP通讯</strong>的时候都要进行Tcp连接，传输 HTTP 数据再断开 TCP 连接的尴尬局面，支持持续性连接，只要浏览器或者服务器没有明确断开连接，则一直保持连接的形式（默认开始keep-alive）让一个 TCP 连接能重复发送&#x2F;接收多次 HTTP 请求<br>如果tcp通道中的某个请求因为某些原因没有及时返回，会堵塞后面的所有请求(<strong>队头堵塞</strong>),<strong>http1.1采用管线化</strong>来处理队头堵塞问题;</p></blockquote><blockquote><p><strong>管线化</strong><br>管线化机制必须通过长连接的形式来实现，HTTP1.1;<br>1.0实现 请求1 -&gt; 响应1 -&gt; 请求2 -&gt; 响应2;<br>1.1实现 请求1 -&gt; 请求2 -&gt; 请求3 -&gt; 响应1 -&gt; 响应2 -&gt; 响应3;<br><strong>两者的区别:</strong><br>http1.0 在于顺序请求，只有在请求1的响应收到之后，才会发送请求2,<br>管线化不需要等待上一次请求得到响应就可以进行下一次请求。实现并行发送请求</p></blockquote><blockquote><p>http1.0一个服务器只能绑定一个域名，<strong>而http1.1在request headers 中添加host字段</strong>,表示当前域名地址，服务器可以根据不同的 Host 值做不同的处理。这样一台物理主机就可以绑定多个虚拟主机，每个虚拟主机都有自己单独的域名。</p></blockquote><h4 id="HTTP-x2F-2-0"><a href="#HTTP-x2F-2-0" class="headerlink" title="HTTP&#x2F;2.0"></a>HTTP&#x2F;2.0</h4><blockquote><p>解决队头堵塞问题，实现资源的并行请求;<br>http2.0使用头部压缩,压缩消息头，减少传输数据的大小;<br>服务器推送：服务端能够主动把资源推送给客户端;<br>HTTP2 可以对比较紧急的请求设置一个较高的优先级，服务器在收到这样的请求后，可以优先处理。</p></blockquote><h4 id="GET-和-POST-的区别"><a href="#GET-和-POST-的区别" class="headerlink" title="GET 和 POST 的区别"></a>GET 和 POST 的区别</h4><blockquote><p>GET 获取数据 POST 提交&#x2F;上传数据;<br>GET 请求长度有限制（是web浏览器的限制,不同的浏览器限制的长度不一样）而 POST 并没有;<br>GET 请求会被浏览器主动保留下来（历史记录），而 POST 默认不会</p></blockquote><h4 id="HTTP-状态码"><a href="#HTTP-状态码" class="headerlink" title="HTTP 状态码"></a>HTTP 状态码</h4><blockquote><p>301 永久重定向   302临时重定向   304协商缓存<br>400 前端参数错误   401没有权限   404报错<br>500服务器报错   502服务器正常、访问出错</p></blockquote><p><strong>非对称加密</strong></p><blockquote><p>有两个秘钥：一个公钥、一个私钥。<br>1.服务器将自己的公钥登录至数字认证机构；<br>2.数字认证机构用自己的私钥向服务器的公钥署数字签名并颁发公钥证书(数字认证机构的公钥证书已经植入到浏览器中);<br>3.客户端拿到服务器的公钥证书后，使用数字证书认证机构的公开密钥向数字证书认证机构验证公钥证书的上的签名，确定服务器公钥的正确性；<br>4.使用服务器的公钥将报文加密后发送<br>5.服务器使用私钥将报文解密<br><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/d4863835ffa54fa4a892988697755b3e~tplv-k3u1fbpfcp-zoom-1.image" alt="非对称加密"><span class="img-alt">非对称加密</span></p></blockquote><h3 id="HTTPS"><a href="#HTTPS" class="headerlink" title="HTTPS"></a>HTTPS</h3><blockquote><p>HTTPS &#x3D; Http + SSL (加密 + 认证 + 完整性验证)<br>通过MD5、SHA1等算法进行完整性的验证，对方收到数据后也生成相同的算法生成散列值，两者相比较从而进行完整性验证;</p></blockquote><blockquote><p>SSL 协议<br>SSL是基于TCP来实现的,但是SSL不属于应用层的协议，他是属于传输层和应用层之间的协议<br>Https &#x3D; Http + SSL, 位于HTTP与TCP&#x2F;IP协议中间</p></blockquote><p><strong>SSL协议握手过程</strong></p><blockquote><p>1、客户端给服务器发送一个消息，信息内容包括：文本内容、客户端支持的加密方式、支持的压缩方法、SSL版本号、客户端生成的随机数;<br>2、服务器收到消息后，也发送一个消息，信息内容包括:文本内容、SSL版本号、服务器生成的随机数、SSL版本号;<br>3、服务器给客户端发送一个报文，报文里面包含于服务器端的公钥；<br>4、服务器发送一个 Server Hello Done, 表示握手建立完成;<br>5、客户端收到握手建立完成的消息后，以Client Key Exchange作为回应,报文中包含通信加密过程中的随机加密串,并且使用收到服务器发送来的公钥来进行加密<br>6、客户端发送Change Cipher Spec报文,该报文告知服务器，接下来的所有请求都会进行加密;<br>7、客户端发送Finish报文，报文中包含连接至今所有报文的整体校验值，用于完整性校验;<br>8、服务器收到客户端发来的Change Cipher Spec报文后，同样也发送Change Cipher Spec报文作为回应<br>9、服务器接收到客户端发来的Finish报文，表示服务端已正确解析客服端发来的整体校验值，SSL握手到此结束;<br>10、开始使用HTTPS协议传输 master secret加密过的数据;<br><img src="https://user-gold-cdn.xitu.io/2018/5/6/1633532f95052afd?imageView2/0/w/1280/h/960/format/webp/ignore-error/1" alt="SSL协议握手过程"><span class="img-alt">SSL协议握手过程</span></p></blockquote><p><strong>HTTPS的优点</strong></p><blockquote><p>使用 HTTPS 协议可认证用户和服务器，确保数据发送到正确的客户机和服务器。<br>HTTPS 协议是由 SSL + HTTP 协议构建的可进行加密传输、身份认证的网络协议，要比 HTTP 协议安全，可防止数据在传输过程中不被窃取、改变，确保数据的完整性。<br>HTTPS 是现行架构下最安全的解决方案，虽然不是绝对安全，但它大幅增加了中间人攻击的成本。</p></blockquote><p><strong>HTTPS的缺点</strong></p><blockquote><p>HTTPS 握手阶段比较费时,会使页面加载时间延长。<br>HTTPS 缓存不如 HTTP 高效，会增加数据开销。<br>SSL 证书需要资金支持，功能越强大的证书费用越高。<br>SSL 证书需要绑定 IP，不能在同一个 IP 上绑定多个域名，IPV4 资源支持不了这种消耗。</p></blockquote><h3 id="HTTP-和-HTTPS-对比"><a href="#HTTP-和-HTTPS-对比" class="headerlink" title="HTTP 和 HTTPS 对比"></a>HTTP 和 HTTPS 对比</h3><blockquote><p><strong>http</strong>是明文传输,<strong>https</strong>属于加密传输<br><strong>https需要CA证书</strong>，资金支持<br><strong>http</strong>的端口为<strong>80</strong>,<strong>https</strong>的端口号为<strong>443</strong>;<br><strong>http</strong>的连接相对简单，是无状态的, <strong>https</strong> 协议是由 <strong>SSL + HTTP</strong> 协议构建的可进行加密传输、身份认证的网络协议，比 <strong>http</strong> 协议安全。</p></blockquote>]]></content>
    
    
      
      
    <summary type="html">&lt;h3 id=&quot;HTTP-7层协议&quot;&gt;&lt;a href=&quot;#HTTP-7层协议&quot; class=&quot;headerlink&quot; title=&quot;HTTP 7层协议&quot;&gt;&lt;/a&gt;HTTP 7层协议&lt;/h3&gt;&lt;blockquote&gt;
&lt;p&gt;7 应用层 例如：(&lt;strong&gt;DNS和HTTP&lt;/s</summary>
      
    
    
    
    <category term="HTTP" scheme="http://yoursite.com/categories/HTTP/"/>
    
    
  </entry>
  
  <entry>
    <title>promise的链式调用</title>
    <link href="http://yoursite.com/2020/11/25/Promise%E7%9A%84%E9%93%BE%E5%BC%8F%E8%B0%83%E7%94%A8/"/>
    <id>http://yoursite.com/2020/11/25/Promise%E7%9A%84%E9%93%BE%E5%BC%8F%E8%B0%83%E7%94%A8/</id>
    <published>2020-11-25T08:30:42.697Z</published>
    <updated>2020-12-04T02:56:59.739Z</updated>
    
    <content type="html"><![CDATA[<h3 id="promise链式调用"><a href="#promise链式调用" class="headerlink" title="promise链式调用"></a>promise链式调用</h3><ul><li><p>回调地狱</p></li><li><p>并发异步io操作,同一时间拿到结果</p></li><li><p>回调函数</p></li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">fs.readFile(&#x27;./1.txt&#x27;,&#x27;utf8&#x27;,(err,data)=&gt;&#123;</span><br><span class="line">    fs.readFile(data,&#x27;utf8&#x27;,(err,data)=&gt;&#123;</span><br><span class="line">        fs.readFile(data,&#x27;utf8&#x27;,(err,data)=&gt;&#123;</span><br><span class="line">            console.log(data) // hello swr</span><br><span class="line">        &#125;)</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><ul><li>Promise<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">read(&#x27;./1.txt&#x27;,&#x27;utf8&#x27;)</span><br><span class="line">.then((data)=&gt;&#123;</span><br><span class="line">    // 1.如果一个promise执行完后，返回的还是一个promise，</span><br><span class="line">    //   会把这个promise的执行结果会传递给下一次then中</span><br><span class="line">    return read(data,&#x27;utf8&#x27;)</span><br><span class="line">&#125;)</span><br><span class="line">.then((data)=&gt;&#123;</span><br><span class="line">    return read(data,&#x27;utf8&#x27;)</span><br><span class="line">&#125;)</span><br><span class="line">.then((data)=&gt;&#123;</span><br><span class="line">    // 2.如果在then中返回的不是一个promise，</span><br><span class="line">    //   而是一个普通值，会将这个普通值作为下次then的成功的结果</span><br><span class="line">    return data.split(&#x27;&#x27;).reverse().join(&#x27;&#x27;)</span><br><span class="line">&#125;)</span><br><span class="line">.then((data)=&gt;&#123;</span><br><span class="line">    console.log(data) // rws olleh</span><br><span class="line">    // 3.如果当前then中失败了，会走下一个then的失败回调</span><br><span class="line">    throw new Error(&#x27;出错&#x27;)</span><br><span class="line">&#125;)</span><br><span class="line">.then(null,(err)=&gt;&#123;</span><br><span class="line">    console.log(err) // Error:出错   报错了</span><br><span class="line">    // 4.如果在then中不返回值，虽然没有显式返回，</span><br><span class="line">    //   但是默认是返回undefined，是属于普通值，依然会把这个普通值传到</span><br><span class="line">    //   下一个then的成功回调中</span><br><span class="line">&#125;)</span><br><span class="line">.then((data)=&gt;&#123;</span><br><span class="line">    console.log(data) // undefined</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><blockquote><p>1.如果一个promise执行完后，返回的还是一个promise，会把这个promise的执行结果会传递给下一次then中<br>2.如果在then中返回的不是一个promise，而是一个普通值，会将这个普通值作为下次then的成功的结果<br>3.如果当前then中失败了，会走下一个then的失败回调<br>4.如果在then中不返回值，虽然没有显式返回，但是默认是返回undefined，是属于普通值，依然会把这个普通值传到下一个then的成功回调中</p></blockquote></li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line">// 如果在then中抛出错误，会怎样呢？</span><br><span class="line">// 情景一，会被下一个then中的失败回调捕获</span><br><span class="line">read(&#x27;./1.txt&#x27;,&#x27;utf8&#x27;)</span><br><span class="line">.then((data)=&gt;&#123;</span><br><span class="line">    throw new Error(&#x27;出错了&#x27;)</span><br><span class="line">&#125;)</span><br><span class="line">.then(null,(err)=&gt;&#123;</span><br><span class="line">    console.log(err) // Error:出错了   报错</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">// 情景二，如果没有被失败的回调捕获，抛出错误最终会变成异常</span><br><span class="line">read(&#x27;./1.txt&#x27;,&#x27;utf8&#x27;)</span><br><span class="line">.then((data)=&gt;&#123;</span><br><span class="line">    throw new Error(&#x27;出错了&#x27;)</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">// 情景三，如果没有被失败的回调捕获，那么最终会被catch捕获到</span><br><span class="line">read(&#x27;./1.txt&#x27;,&#x27;utf8&#x27;)</span><br><span class="line">.then((data)=&gt;&#123;</span><br><span class="line">    throw new Error(&#x27;出错了&#x27;)</span><br><span class="line">&#125;)</span><br><span class="line">.then((data)=&gt;&#123;</span><br><span class="line">    </span><br><span class="line">&#125;)</span><br><span class="line">.catch((err)=&gt;&#123;</span><br><span class="line">    console.log(err) // Error:出错了   报错</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">// 情景四，如果被失败的回调捕获了，那么不会被catch捕获到</span><br><span class="line">read(&#x27;./1.txt&#x27;,&#x27;utf8&#x27;)</span><br><span class="line">.then((data)=&gt;&#123;</span><br><span class="line">    throw new Error(&#x27;出错了&#x27;)</span><br><span class="line">&#125;)</span><br><span class="line">.then(null,(err)=&gt;&#123;</span><br><span class="line">    console.log(err) // Error:出错了   报错</span><br><span class="line">&#125;)</span><br><span class="line">.catch((err)=&gt;&#123;</span><br><span class="line">    console.log(err)  // 不会执行到这里</span><br><span class="line">&#125;)</span><br><span class="line"></span><br></pre></td></tr></table></figure><blockquote><p>then 里面可以不写东西<br>catch是错误没有处理的情况下才能执行</p></blockquote><h3 id="实现promise链式调用"><a href="#实现promise链式调用" class="headerlink" title="实现promise链式调用"></a>实现promise链式调用</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">let promise = new Promise((resolve,reject)=&gt;&#123;</span><br><span class="line">    resolve()</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">// 2.返回的值为promise2,这是promiseA+规范规定的</span><br><span class="line">let promise2 = promise.then((data)=&gt;&#123;</span><br><span class="line">    return x // then中的返回值x可能是普通值也可能是promise，并且传给下一个then</span><br><span class="line">&#125;).then((data)=&gt;&#123;</span><br><span class="line">    console.log(data) // x的值</span><br><span class="line">&#125;)</span><br><span class="line"></span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br></pre></td><td class="code"><pre><span class="line">// 源码</span><br><span class="line">function Promise(executor)&#123;</span><br><span class="line">    let self = this</span><br><span class="line">    self.value = undefined  // 成功的值</span><br><span class="line">    self.reason = undefined // 失败的值</span><br><span class="line">    self.status = &#x27;pending&#x27; // 初始化状态</span><br><span class="line">    self.onResolvedCallbacks = []  // 成功的回调</span><br><span class="line">    self.onRejectedCallbacks = []  // 失败的回调</span><br><span class="line">    function resolve(value)&#123;</span><br><span class="line">        if(self.status === &#x27;pending&#x27;)&#123;  // 只有在pending的状态才能转为成功态</span><br><span class="line">            self.value = value </span><br><span class="line">            self.status = &#x27;resolved&#x27;</span><br><span class="line">            self.onResolvedCallbacks.forEach(fn=&gt;fn())  // 可能new Promise的时候会存在异步操作，把成功和失败的回调保存起来</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    function reject(reason)&#123;</span><br><span class="line">        if(self.status === &#x27;pending&#x27;)&#123; // 只有在pending的状态才能转为失败态</span><br><span class="line">            self.reason = reason </span><br><span class="line">            self.status = &#x27;rejected&#x27;</span><br><span class="line">            self.onRejectedCallbacks.forEach(fn=&gt;fn())</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    try&#123;</span><br><span class="line">         // 在new Promise的时候，立即执行的函数，称为执行器</span><br><span class="line">        executor(resolve,reject)</span><br><span class="line">    &#125;catch(error)&#123; // 如果执行executor抛出错误，则会走失败reject</span><br><span class="line">        reject(error)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Promise.prototype.then = function(onFulfilled,onRejected)&#123;</span><br><span class="line">    let self = this</span><br><span class="line">    let promise2 // promise链式调用时，返回的是一个新的promise对象，在这里声明一个新的promise</span><br><span class="line">    </span><br><span class="line">     promise2 = new Promise((resolve,reject)=&gt;&#123;</span><br><span class="line">        if(self.status === &#x27;resolved&#x27;)&#123;</span><br><span class="line">            // 当执行成功回调的时候，可能会出现异常，那么就把这个异常作为promise2的错误的结果</span><br><span class="line">            try&#123;</span><br><span class="line">                let x = onFulfilled(self.value) // x，代表then中执行完返回的结果</span><br><span class="line">                // 根据promiseA+规范，我们应该提供一个函数来处理promise2</span><br><span class="line">                //   个人的理解:then中不管是成功回调还是失败回调，其返回</span><br><span class="line">                //   值，有可能是promise，也有可能是普通值，也有可能是抛出错误</span><br><span class="line">                //   那么就需要一个函数来处理这几种不同的情况</span><br><span class="line">                resolvePromise(promise2,x,resolve,reject)</span><br><span class="line">                // 这里的promise2就是当前的promise2，x则是执行then中成功回调后返回的结果，如果是成功则调promise2的resolve，失败则调reject</span><br><span class="line">            &#125;catch(e)&#123;</span><br><span class="line">                reject(e) // 注意：这里的reject是这个promise2的reject</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        if(self.status === &#x27;rejected&#x27;)&#123;</span><br><span class="line">            try&#123;</span><br><span class="line">                let x = onRejected(self.reason) </span><br><span class="line">                resolvePromise(promise2,x,resolve,reject)</span><br><span class="line">            &#125;catch(e)&#123;</span><br><span class="line">                reject(e)</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        if(self.status === &#x27;pending&#x27;)&#123;</span><br><span class="line">            self.onResolvedCallbacks.push(()=&gt;&#123;</span><br><span class="line">                try&#123;</span><br><span class="line">                    let x =  onFulfilled(self.value)</span><br><span class="line">                    resolvePromise(promise2,x,resolve,reject)</span><br><span class="line">                &#125;catch(e)&#123;</span><br><span class="line">                    reject(e)</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;) </span><br><span class="line">            self.onRejectedCallbacks.push(()=&gt;&#123;</span><br><span class="line">                try&#123;</span><br><span class="line">                    let x = onRejected(self.reason)</span><br><span class="line">                    resolvePromise(promise2,x,resolve,reject)</span><br><span class="line">                &#125;catch(e)&#123;</span><br><span class="line">                    reject(e)</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;)</span><br><span class="line">    return promise2 // 在jquery中是return this，但是在promise中，则是返回一个新的promise对象</span><br><span class="line">&#125;</span><br><span class="line">module.exports = Promise</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="完整代码"><a href="#完整代码" class="headerlink" title="完整代码"></a>完整代码</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">function Promise(executor) &#123;</span><br><span class="line">    let self = this;</span><br><span class="line">    self.value = undefined;  // 成功的值</span><br><span class="line">    self.reason = undefined;  // 失败的值</span><br><span class="line">    self.status = &#x27;pending&#x27;; // 目前promise的状态pending</span><br><span class="line">    self.onResolvedCallbacks = []; // 可能new Promise的时候会存在异步操作，把成功和失败的回调保存起来</span><br><span class="line">    self.onRejectedCallbacks = [];</span><br><span class="line">    function resolve(value) &#123; // 把状态更改为成功</span><br><span class="line">        if (self.status === &#x27;pending&#x27;) &#123; // 只有在pending的状态才能转为成功态</span><br><span class="line">            self.value = value;</span><br><span class="line">            self.status = &#x27;resolved&#x27;;</span><br><span class="line">            self.onResolvedCallbacks.forEach(fn =&gt; fn()); // 把new Promise时异步操作，存在的成功回调保存起来</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    function reject(reason) &#123;  // 把状态更改为失败</span><br><span class="line">        if (self.status === &#x27;pending&#x27;) &#123; // 只有在pending的状态才能转为失败态</span><br><span class="line">            self.reason = reason;</span><br><span class="line">            self.status = &#x27;rejected&#x27;;</span><br><span class="line">            self.onRejectedCallbacks.forEach(fn =&gt; fn()); // 把new Promise时异步操作，存在的失败回调保存起来</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    try &#123;</span><br><span class="line">        // 在new Promise的时候，立即执行的函数，称为执行器</span><br><span class="line">        executor(resolve, reject);</span><br><span class="line">    &#125; catch (e) &#123; // 如果执行executor抛出错误，则会走失败reject</span><br><span class="line">        reject(e);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br></pre></td><td class="code"><pre><span class="line">Promise.prototype.then = function(onFulfilled,onRejected)&#123;</span><br><span class="line">    // onFulfilled、onRejected是可选参数</span><br><span class="line">    onFulfilled = typeof onFulfilled === &#x27;function&#x27;?onFulfilled:val=&gt;val;</span><br><span class="line">    onRejected = typeof onRejected === &#x27;function&#x27;?onRejected: err=&gt;&#123;throw err&#125;;</span><br><span class="line">    let self = this;</span><br><span class="line">    let promise2; </span><br><span class="line">     // promise和jquery的区别是 promise不能单纯返回自身，</span><br><span class="line">    // 而是每次都是返回一个新的promise，才可以实现链式调用，</span><br><span class="line">   // 因为同一个promise的pending resolve reject只能更改一次</span><br><span class="line">     promise2 = new Promise((resolve,reject)=&gt;&#123;</span><br><span class="line">        if(self.status === &#x27;resolved&#x27;)&#123;</span><br><span class="line">          // 为什么要加setTimeout？</span><br><span class="line">         // 首先是promiseA+规范要求的</span><br><span class="line">        // 其次是代码，有的是同步，有的是异步</span><br><span class="line">       // 所以为了更加统一，就使用为setTimeout变为异步了，保持一致性</span><br><span class="line">            setTimeout(()=&gt;&#123;</span><br><span class="line">              try &#123; // 上面executor虽然使用try catch捕捉错误</span><br><span class="line">                // 但是在异步中，不一定能够捕捉，所以在这里</span><br><span class="line">                // 用try catch捕捉</span><br><span class="line">              let x = onFulfilled(self.value);</span><br><span class="line">              // 在then中，返回值可能是一个promise，所以</span><br><span class="line">              // 需要resolvePromise对返回值进行判断</span><br><span class="line">               resolvePromise(promise2,x,resolve,reject)</span><br><span class="line">                &#125;catch(e)&#123;</span><br><span class="line">                    reject(e) </span><br><span class="line">                &#125;</span><br><span class="line">            &#125;,0)</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        if(self.status === &#x27;rejected&#x27;)&#123;</span><br><span class="line">            setTimeout(()=&gt;&#123;</span><br><span class="line">                try&#123;</span><br><span class="line">                    let x = onRejected(self.reason) </span><br><span class="line">                    resolvePromise(promise2,x,resolve,reject)</span><br><span class="line">                &#125;catch(e)&#123;</span><br><span class="line">                    reject(e)</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;,0)</span><br><span class="line">        &#125;</span><br><span class="line">       // 当new Promise中有resolve、reject处于异步中，执行then的时候，状态为pending，</span><br><span class="line">        if(self.status === &#x27;pending&#x27;)&#123;</span><br><span class="line">            // 分别把成功、失败的回调函数，存到该数组中，这样写的好处，就是把参数传进去，不需要将来遍历onResolvedCallbacks、onRejectedCallbacks时，再传参</span><br><span class="line">            self.onResolvedCallbacks.push(()=&gt;&#123;</span><br><span class="line">                setTimeout(()=&gt;&#123;</span><br><span class="line">                    try&#123;</span><br><span class="line">                        let x =  onFulfilled(self.value)</span><br><span class="line">                        resolvePromise(promise2,x,resolve,reject)</span><br><span class="line">                    &#125;catch(e)&#123;</span><br><span class="line">                        reject(e)</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;,0)</span><br><span class="line">            &#125;) </span><br><span class="line"></span><br><span class="line">            self.onRejectedCallbacks.push(()=&gt;&#123;</span><br><span class="line">                setTimeout(()=&gt;&#123;</span><br><span class="line">                    try&#123;</span><br><span class="line">                        let x = onRejected(self.reason)</span><br><span class="line">                        resolvePromise(promise2,x,resolve,reject)</span><br><span class="line">                    &#125;catch(e)&#123;</span><br><span class="line">                        reject(e)</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;,0)</span><br><span class="line">            &#125;)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;)</span><br><span class="line">    return promise2</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>说明 call 的意义</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">promise.then(()=&gt;&#123;</span><br><span class="line">    console.log(this) // 此时this是指向该promise的，对象的方法中this是指向这个对象的</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><blockquote><p>但是我们在下面通过let then &#x3D; promise.then，来判断是否promise，是否会异常<br>当我们执行then时，里面的this还是会指向这个promise吗？答案是不一定的，<br>因为此时then，如果在全局下执行，指向的可能就是window了，所以为了让this的<br>指向正确，需要通过<br>then.call(promise)，来把then的this指向promise</p></blockquote><h3 id="这个函数为核心主要是处理then中返回的值x和promise2的关系"><a href="#这个函数为核心主要是处理then中返回的值x和promise2的关系" class="headerlink" title="这个函数为核心主要是处理then中返回的值x和promise2的关系"></a>这个函数为核心主要是处理then中返回的值x和promise2的关系</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line">function resolvePromise(promise2,x,resolve,reject)&#123;</span><br><span class="line">// 当promise2和then返回的值x为同一个对象时，变成了自己等自己，会陷入死循环</span><br><span class="line">if(promise2 === x)&#123;</span><br><span class="line">  return reject(new TypeError(&#x27;Chaining cycle&#x27;));</span><br><span class="line">&#125;</span><br><span class="line">let called;</span><br><span class="line">// x可能是一个promise也可能是一个普通值</span><br><span class="line">if(x!==null &amp;&amp; (typeof x=== &#x27;object&#x27; || typeof x === &#x27;function&#x27;))&#123;</span><br><span class="line">  try&#123;</span><br><span class="line">      // 这里的x，就是上面then中执行完返回的结果，我们在这里声明一个x用来接收</span><br><span class="line">      // 返回的必须是一个新的promise，因为promise成功后不能再走失败</span><br><span class="line">      let then = x.then; </span><br><span class="line">      // x可能还是个promise，那么就让这个promise执行</span><br><span class="line">      // 但是还是存在一个恶作剧的情况，就是&#123;then:&#123;&#125;&#125;</span><br><span class="line">      // 此时需要新增一个判断then是否函数</span><br><span class="line">      if(typeof then === &#x27;function&#x27;)&#123;</span><br><span class="line">        then.call(x,y=&gt;&#123;  // y 是返回promise后的成功结果</span><br><span class="line">              if(called) return; </span><br><span class="line">              called = true;</span><br><span class="line">      // 只能创建一个新的promise再执行业务逻辑，返回同一个promise的话，就不能既成功又失败</span><br><span class="line">              resolvePromise(promise2,y,resolve,reject);</span><br><span class="line">          &#125;,err=&gt;&#123; </span><br><span class="line">              if(called) return;</span><br><span class="line">              called = true;</span><br><span class="line">              reject(err);</span><br><span class="line">          &#125;);</span><br><span class="line">      &#125;else&#123;</span><br><span class="line">          resolve(x);</span><br><span class="line">      &#125;</span><br><span class="line">  &#125;catch(e)&#123;</span><br><span class="line">      if(called) return;</span><br><span class="line">      called = true;</span><br><span class="line">      reject(e);</span><br><span class="line">  &#125;</span><br><span class="line"> &#125;else&#123; </span><br><span class="line">  resolve(x);</span><br><span class="line"> &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h3 id=&quot;promise链式调用&quot;&gt;&lt;a href=&quot;#promise链式调用&quot; class=&quot;headerlink&quot; title=&quot;promise链式调用&quot;&gt;&lt;/a&gt;promise链式调用&lt;/h3&gt;&lt;ul&gt;
&lt;li&gt;&lt;p&gt;回调地狱&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;并发异</summary>
      
    
    
    
    <category term="2020" scheme="http://yoursite.com/categories/2020/"/>
    
    
  </entry>
  
  <entry>
    <title>前端性能优化 (2020)</title>
    <link href="http://yoursite.com/2020/11/18/2020%E5%89%8D%E7%AB%AF%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96/"/>
    <id>http://yoursite.com/2020/11/18/2020%E5%89%8D%E7%AB%AF%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96/</id>
    <published>2020-11-18T03:42:29.733Z</published>
    <updated>2020-12-16T15:49:33.455Z</updated>
    
    <content type="html"><![CDATA[<h3 id="1-减少HTTP请求"><a href="#1-减少HTTP请求" class="headerlink" title="1.减少HTTP请求"></a>1.减少HTTP请求</h3><blockquote><ul><li>一个 <strong>完整</strong> 的HTTP请求过程分为<br><strong>1.DNS查询得到IP地址</strong><br><strong>2.客户端与服务器建立连接（俗称TCP三次握手）</strong><br><strong>3.客户端发起请求</strong><br><strong>4.服务器接收到请求根据端口号、路径，去查找指定的资源文件，响应状态给客户端</strong><br><strong>5.客户端接收到请求数据后开始解析，以及请求剩余资源</strong><br><strong>6.客户端开始解析页面</strong><br><strong>7.客户端与服务器断开连接(四次挥手)</strong></li></ul></blockquote><h3 id="2-使用-HTTP2"><a href="#2-使用-HTTP2" class="headerlink" title="2.使用 HTTP2"></a>2.使用 HTTP2</h3><p><strong>解析速度快</strong></p><ul><li>对于2.0之前的版本服务器解析http请求是通过不断去解析字节,直到遇到了分隔符 <strong>CRLF(响应截断)</strong> 为止</li><li>对于HTTP2来讲，HTTP是基于<strong>帧</strong>的协议，每个帧都有表示<strong>帧</strong>长度的字段</li></ul><blockquote><p><strong>CRLF(响应截断)</strong></p></blockquote><ul><li>所谓的CRLF是<strong>由CR和LF两个字段</strong>拼接而成,分别代表<strong>回车和换行</strong>,而在HTTP协议中，HTTP header之间是由一个CRLF字符序列分隔开的，HTTP Header与Body是用两个CRLF分隔的，浏览器根据这两个CRLF来取出HTTP内容并显示出来。</li></ul><p><strong>多路复用</strong></p><ul><li>对于HTTP1.1来讲，如果同时发起多个请求则需要每一个单独处理，因为TCP同时只能处理一个HTTP1.1请求</li><li>HTTP2来讲多个请求可以共用一个 TCP 连接,同一个请求和响应用一个流来表示，并通过唯一的流 ID 来标识,即使多个请求和响应在TCP中乱序发送，也可以通过流ID来进行重组</li></ul><p><strong>首部压缩</strong><br>对于 <strong>HTTP2</strong> 来讲请求头中数据重复则会进行首部存储 (客户端和服务端使用首部表来追踪和存储之前发送的键值对，对于相同的数据则不再发送)，仅发送他们不同的部分</p><p><strong>服务器推送</strong><br>HTTP2可以向客户端推送除了HTML页面外，服务器也可以根据HTML页面中的资源的 URL，来提前推送资源</p><h3 id="3-使用服务端渲染"><a href="#3-使用服务端渲染" class="headerlink" title="3.使用服务端渲染"></a>3.使用服务端渲染</h3><blockquote><p><strong>客户端渲染:</strong><br>1.根据 HTML 解析生成 DOM树<br>2.css 解析生成 css树<br>3.结合 <strong>DOM树</strong> 和 <strong>CSS规则树</strong> 生成 <strong>渲染树</strong><br>4.根据渲染树计算每个节点的信息<br>5.根据计算好的节点信息去渲染页面<br><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/e927ffe33f3d4bdba64e179e9c793bb9~tplv-k3u1fbpfcp-zoom-1.image" alt="客户端渲染"><span class="img-alt">客户端渲染</span></p></blockquote><p><strong>服务端渲染:</strong></p><blockquote><p>服务端返回HTML，客户端仅需要解析HTML文件即可</p></blockquote><ul><li>优点:首屏幕渲染快，SEO好</li><li>缺点:配置成本高，增加服务器压力</li></ul><h3 id="4-静态资源CDN加载"><a href="#4-静态资源CDN加载" class="headerlink" title="4.静态资源CDN加载"></a>4.静态资源CDN加载</h3><p><strong>CDN原理</strong></p><blockquote><p>当用户访问一个网站没有CDN则:<br>1.浏览器需要将域名解析为IP地址，需要向本地DNS发出请求<br>2.本地服务器依次向根服务器、顶级域名服务器，权限服务器发出请求，得到该网站服务器的ip地址<br>3.本地DNS将ip地址发回给浏览器，浏览器向网站服务器ip发送请求并得到资源<br><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/7d25d1b0091b4e00ae51789172a46d2d~tplv-k3u1fbpfcp-zoom-1.image" alt="无CDN"><span class="img-alt">无CDN</span></p></blockquote><blockquote><p><strong>网站部署了CDN</strong><br>1.浏览器将域名解析为IP地址，需要向本地DNS发出请求<br>2.本地服务器依次向根服务器、顶级域名服务器、权限服务器发出请求，得到全局负载均衡（GSLB）的IP地址<br>3.本地服务器再向 GSLB 发送请求, GSLB的主要作用是根据本地DNS的IP判断用户的位置,筛选出距离当前用户最近的本地负载均衡系统（SLB）然后将该SLB的IP地址作为结果返回给本地DNS<br>4.本地DNS 将 SLB的IP地址 发回给浏览器，浏览器向SLB发送请求<br>5.SLB将浏览器请求的资源和地址，选出最优的缓存服务器发回给浏览器<br>6.浏览器再根据SLB发回的地址重定向到缓存服务器<br>7.如果缓存浏览器有浏览器需要的资源，会将资源发回给浏览器，如果没有，就向源服务器请求资源再发给浏览器并缓存在本地<br><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/67c19972e7dd4ae0840a0f838dd6a017~tplv-k3u1fbpfcp-zoom-1.image" alt="CDN"><span class="img-alt">CDN</span></p></blockquote><h3 id="5-减少重绘重排"><a href="#5-减少重绘重排" class="headerlink" title="5.减少重绘重排"></a>5.减少重绘重排</h3><h6 id="重绘不一定会发生回流，回流必然发生重绘"><a href="#重绘不一定会发生回流，回流必然发生重绘" class="headerlink" title="重绘不一定会发生回流，回流必然发生重绘"></a>重绘不一定会发生回流，回流必然发生重绘</h6><ul><li>回流:添加或删除可见的DOM元素、浏览器窗口尺寸改变、内容改变、元素的大小、位置发生变化时,称之为回流;</li><li>重绘:当元素的颜色，背景色发生变化时,称之为重绘;</li></ul><h3 id="6-将-CSS-放在文件头部，JavaScript-文件放在底部"><a href="#6-将-CSS-放在文件头部，JavaScript-文件放在底部" class="headerlink" title="6.将 CSS 放在文件头部，JavaScript 文件放在底部"></a>6.将 CSS 放在文件头部，JavaScript 文件放在底部</h3><blockquote><p>1.所有放在head标签里面的css&#x2F;js文件都会堵塞渲染，如果文件过大容易造成页面空白，所以需要将js放在底部，等待HTML解析完成后才去加载js<br>2.将css放在头部的原因是：为了避免渲染HTML时没有样式，页面丑陋<br>3.如果将js文件放在头部加载的话，需要将 script 标签加上 defer 属性就可以，异步加载，延迟执行</p></blockquote>]]></content>
    
    
      
      
    <summary type="html">&lt;h3 id=&quot;1-减少HTTP请求&quot;&gt;&lt;a href=&quot;#1-减少HTTP请求&quot; class=&quot;headerlink&quot; title=&quot;1.减少HTTP请求&quot;&gt;&lt;/a&gt;1.减少HTTP请求&lt;/h3&gt;&lt;blockquote&gt;
&lt;ul&gt;
&lt;li&gt;一个 &lt;strong&gt;完整&lt;/stro</summary>
      
    
    
    
    <category term="2020" scheme="http://yoursite.com/categories/2020/"/>
    
    
  </entry>
  
  <entry>
    <title>promise</title>
    <link href="http://yoursite.com/2020/03/07/promise%E5%AE%9E%E7%8E%B0/"/>
    <id>http://yoursite.com/2020/03/07/promise%E5%AE%9E%E7%8E%B0/</id>
    <published>2020-03-07T09:35:32.557Z</published>
    <updated>2020-11-24T11:55:27.685Z</updated>
    
    <content type="html"><![CDATA[<h3 id="promise-特性"><a href="#promise-特性" class="headerlink" title="promise 特性"></a>promise 特性</h3><blockquote><p>promise 三个状态 pending等待、resolved成功、rejected失败<br>promise的三个状态是可以切换的，可以从pending -&gt; resolved 或 pending -&gt; rejected，但是resolved不能转换为rejected&#x2F;pending，rejected不能转换为resolved&#x2F;pending，并且<strong>状态只会更改一次</strong></p></blockquote><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">Promise构造函数的第一个参数为executor</span><br><span class="line">  let promise = new Promise(function(resolve,reject)&#123;</span><br><span class="line">    console.log(&#x27;我是会被立即执行的哟&#x27;)</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">// promise的实例都有then方法</span><br><span class="line">  promise.then((resolve)=&gt;&#123; // 成功的回调</span><br><span class="line">    </span><br><span class="line">  &#125;,(reject)=&gt;&#123; // 失败的回调</span><br><span class="line">    </span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><ul><li>executor<strong>默认在new的时候</strong>会自动执行;</li><li>每个<strong>promise实例</strong>都有then方法</li><li>then方法里面有两个参数，分别是<strong>成功</strong>、<strong>失败</strong>的回调</li><li>如果状态为pending,则不会执行then成功、失败回调函数</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">  promise.then(()=&gt;&#123;</span><br><span class="line">    console.log(&#x27;success1&#x27;)</span><br><span class="line">  &#125;,()=&gt;&#123;</span><br><span class="line">    console.log(&#x27;error1&#x27;)</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">console.log(&#x27;2&#x27;)</span><br></pre></td></tr></table></figure><ul><li>then方法是异步操作、属于微任务，先执行完同步代码、在执行异步代码</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">  let promise2 = new promise((resolve,reject)=&gt;&#123;</span><br><span class="line">    console.log(1);</span><br><span class="line">    resolve();</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">  promise2.then(()=&gt;&#123;</span><br><span class="line">    console.log(&#x27;成功&#x27;);</span><br><span class="line">  &#125;,()=&gt;&#123;</span><br><span class="line">    console.log(&#x27;失败&#x27;); </span><br><span class="line">&#125;)</span><br><span class="line">    console.log(&#x27;2&#x27;); </span><br><span class="line"></span><br><span class="line">log 执行顺序 1=&gt;2=&gt;&#x27;成功&#x27;</span><br></pre></td></tr></table></figure><ul><li>同一个promise的实例可以执行多个then的链式调用，成功时会调用所有的成功方法，失败则会调用所有的失败方法</li><li>new promise中可以支持异步</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">let promise2 = new Promise(function(resolve,reject)&#123;</span><br><span class="line">     throw new Error(&#x27;出错了&#x27;) // 抛出错误</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">  promise.then(()=&gt;&#123;</span><br><span class="line">    console.log(&#x27;成功&#x27;)</span><br><span class="line">  &#125;,()=&gt;&#123;</span><br><span class="line">  console.log(&#x27;失败&#x27;)  // 执行</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><h3 id="promise-实现"><a href="#promise-实现" class="headerlink" title="promise 实现"></a>promise 实现</h3><ul><li>executor默认在new的时候会自动执行</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">  let promise2 = new Promise((resolve,reject)=&gt;&#123;  // 成功、失败的回调</span><br><span class="line">   setTimeout(()=&gt;&#123; //  此时resolve处于异步</span><br><span class="line">        resolve(&#x27;hello promise&#x27;);</span><br><span class="line">    &#125;,3000)</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">  promise2.then((data)=&gt;&#123;  //成功</span><br><span class="line">    console.log(data)</span><br><span class="line">  &#125;,(err)=&gt;&#123;  //失败</span><br><span class="line"></span><br><span class="line">  &#125;)</span><br></pre></td></tr></table></figure><h3 id="源码实现"><a href="#源码实现" class="headerlink" title="源码实现"></a>源码实现</h3><ul><li>因为Promise的实例都有then方法，也就是说then方法属于Promise原型上的方法;</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line">function Promise (executor)&#123;</span><br><span class="line">    let _this = this;</span><br><span class="line">    // value和reason的值需要在Promise实例中的then回调方法里面去使用,所以要将他们赋值给new出来的实例</span><br><span class="line">    _this.value = undefined;</span><br><span class="line">    _this.reason = undefined;</span><br><span class="line">    // promise 只能转换为一种状态</span><br><span class="line">    _this.status = &#x27;pengding&#x27;;</span><br><span class="line">    _this.onResolvedCallbacks = [] // 可能new Promise中会有异步的操作，此时我们把异步操作时，执行的then函数的成功回调，统一保存在该数组中</span><br><span class="line">    _this.onRejectedCallbacks = [] //可能new Promise中会有异步的操作，此时我们把异步操作时，执行的then函数的失败回调，统一保存在该数组中</span><br><span class="line"> </span><br><span class="line">  function resolve(value)&#123;  // 声明resolve方法</span><br><span class="line">    if(_this.status === &#x27;pending&#x27;)&#123;</span><br><span class="line">    _this.value = value;</span><br><span class="line">    _this.status = &#x27;resolve&#x27;; // 把该数组中存放的成功回调都执行一遍</span><br><span class="line">    _this.onResolvedCallbacks.forEach(fn=&gt;fn())</span><br><span class="line">   &#125;</span><br><span class="line">  &#125;;</span><br><span class="line"></span><br><span class="line">  function reject(reason)&#123;  // 声明reject方法</span><br><span class="line">    if(_this.status === &#x27;pending&#x27;)&#123;</span><br><span class="line">     _this.reason = reason; </span><br><span class="line">     _this.status = &#x27;reject&#x27;; // 把该数组中存放的失败回调都执行一遍</span><br><span class="line">     _this.onRejectedCallbacks.forEach(fn=&gt;fn())</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;;</span><br><span class="line">  // 如果执行executor时，内部出现错误</span><br><span class="line">  try&#123;</span><br><span class="line">      executor(resolve,reject) // 将成功、失败的方法传到executor;</span><br><span class="line">  &#125;catch(error=&gt;&#123;</span><br><span class="line">       reject(error)</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">  // 成功的回调函数onFulfilled以及失败的回调函数onRejected</span><br><span class="line">  Promise.prototype.then = function(onFulfilled,onRejected)&#123;</span><br><span class="line">      let self = this;</span><br><span class="line">      if(self.status === &#x27;resolved&#x27;)&#123;</span><br><span class="line">        onFulfilled(self.value) </span><br><span class="line">    &#125;;</span><br><span class="line">     if(self.status === &#x27;rejected&#x27;)&#123;</span><br><span class="line">        onRejected(self.reason) </span><br><span class="line">    &#125;;</span><br><span class="line">    if(self.status === &#x27;pending&#x27;)&#123;</span><br><span class="line">        self.onResolvedCallbacks.push(()=&gt;&#123;</span><br><span class="line">        onFulfilled(self.value)</span><br><span class="line">    &#125;) // 把成功的回调函数，存到该数组中，这样写的好处，就是把参数传进去，不需要将来遍历onResolvedCallbacks时，再传参</span><br><span class="line">        self.onRejectedCallbacks.push(()=&gt;&#123;</span><br><span class="line">        onRejected(self.reason)</span><br><span class="line">    &#125;) // 把失败的回调函数，存到该数组中，这样写的好处，就是把参数传进去，不需要将来遍历onRejectedCallbacks时，再传参</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">  module.exports = Promise;</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h3 id=&quot;promise-特性&quot;&gt;&lt;a href=&quot;#promise-特性&quot; class=&quot;headerlink&quot; title=&quot;promise 特性&quot;&gt;&lt;/a&gt;promise 特性&lt;/h3&gt;&lt;blockquote&gt;
&lt;p&gt;promise 三个状态 pending等待、re</summary>
      
    
    
    
    <category term="2020" scheme="http://yoursite.com/categories/2020/"/>
    
    
  </entry>
  
  <entry>
    <title>JS基础、原理</title>
    <link href="http://yoursite.com/2019/11/19/js%E5%9F%BA%E7%A1%80%E3%80%81%E5%8E%9F%E7%90%86/"/>
    <id>http://yoursite.com/2019/11/19/js%E5%9F%BA%E7%A1%80%E3%80%81%E5%8E%9F%E7%90%86/</id>
    <published>2019-11-19T15:52:54.748Z</published>
    <updated>2019-11-19T16:54:07.897Z</updated>
    
    <content type="html"><![CDATA[<h3 id="New的原理"><a href="#New的原理" class="headerlink" title="New的原理"></a>New的原理</h3><ul><li>1、创建一个空对象，构造函数中的this指向这个空对象</li><li>2、这个新对象被执行[[原型]]连接</li><li>3、执行构造函数方法，属性和方法被添加到 <strong>this</strong> 引用的对象中去</li><li>4、如果构造函数中没有返回其他对象，那么返回this,即创建这个新对象,否则,返回构造函数中返回的对象</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">function _news() &#123;</span><br><span class="line">    let target = &#123;&#125;;  // 创建一个新对象 </span><br><span class="line">    // 第一个参数是构造函数</span><br><span class="line">    let [constructor,...args] = [...arguments];</span><br><span class="line">    // 执行[[原型]] 连接; target 是 constructor 的实例</span><br><span class="line">    target.__proto__ = constructor.prototype;</span><br><span class="line">    // 执行构造函数,将属性或方法添加都创建的空对象上</span><br><span class="line">    let result = constructor.apply(target,args);</span><br><span class="line">    // 如何构造函数返回的是一个对象</span><br><span class="line">    if(result &amp;&amp; (typeof (result) == &#x27;object&#x27; || typeof (result) == &#x27;function&#x27;))&#123;</span><br><span class="line">        // 返回该对象</span><br><span class="line">        return result</span><br><span class="line">    &#125;</span><br><span class="line">    // 如果构造函数返回的不是一个对象，则返回新创建的对象</span><br><span class="line">    return  target</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="如何正确判断-this-指向问题"><a href="#如何正确判断-this-指向问题" class="headerlink" title="如何正确判断 this 指向问题"></a>如何正确判断 this 指向问题</h3><ul><li>浏览器中, (无论是否在严格模式下) 在全局环境下 this 指向是window</li><li>node中 (无论是否在严格模式下) this 都是指向空对象 {}</li></ul><h4 id="是否是-new、绑定"><a href="#是否是-new、绑定" class="headerlink" title="是否是 new、绑定"></a>是否是 new、绑定</h4><blockquote><p>构造函数返回值不是 <strong>function</strong> 或 <strong>object</strong>  那么 this 指向这个新对象</p></blockquote><p><strong>函数是否通过 call,apply 调用，或者使用了 bind 绑定，如果是，那么this绑定的就是指定的对象【归结为显式绑定】</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">function info () &#123;</span><br><span class="line">    console.log(this.age);</span><br><span class="line">&#125;</span><br><span class="line">let parents = &#123;</span><br><span class="line">    age:20,</span><br><span class="line">    info</span><br><span class="line">&#125;</span><br><span class="line">var age = 28;</span><br><span class="line">var info = parents.info;</span><br><span class="line"></span><br><span class="line">info.call(parents);</span><br><span class="line">info.apply(parents);</span><br><span class="line">info.bind(parents)();</span><br></pre></td></tr></table></figure><h4 id="箭头函数中的this"><a href="#箭头函数中的this" class="headerlink" title="箭头函数中的this"></a>箭头函数中的this</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">let obj = &#123;</span><br><span class="line">    age:20,</span><br><span class="line">    info:function () &#123;</span><br><span class="line">        return ()=&gt;&#123;</span><br><span class="line">            console.log(this.age)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">let parent = &#123;age:28&#125;;</span><br><span class="line">let info = obj.info();</span><br><span class="line">info();</span><br><span class="line">let info2 = obj.info.call(parent);</span><br><span class="line">info2();</span><br></pre></td></tr></table></figure><h4 id="深拷贝和浅拷贝的区别，如何实现一个深拷贝"><a href="#深拷贝和浅拷贝的区别，如何实现一个深拷贝" class="headerlink" title="深拷贝和浅拷贝的区别，如何实现一个深拷贝"></a>深拷贝和浅拷贝的区别，如何实现一个深拷贝</h4><blockquote><p>深拷贝和浅拷贝的区别: 深拷贝是层层拷贝，浅拷贝是拷贝一层</p></blockquote><p><strong>深拷贝</strong></p><blockquote><p>深拷贝复制变量值,对于非基本类型的变量，则递归到基本类型变量后在复制。深拷贝后的对象与原来的对象是完全隔离的，互不影响，对一个对象的修改并不会影响另一个对象。</p></blockquote><p><strong>浅拷贝</strong></p><blockquote><p>浅拷贝是会将对象的每个属性进行依次复制，但是当对象的属性值是引用类型时，实质复制的是其引用，当引用指向的值改变时也会跟着变化。</p></blockquote><blockquote><p>可以使用 for in、 Object.assign、 扩展运算符 … 、Array.prototype.slice()、Array.prototype.concat() 等</p></blockquote><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">let obj = &#123;</span><br><span class="line">    name:&#x27;zz&#x27;,</span><br><span class="line">    age:18,</span><br><span class="line">    aa:[&#x27;reading&#x27;,&#x27;book&#x27;]</span><br><span class="line">&#125;;</span><br><span class="line">let obj2 = Object.assign(&#123;&#125;,obj);</span><br><span class="line">let obj3 = obj;</span><br><span class="line">obj.name = &#x27;aa&#x27;;</span><br><span class="line">obj.aa.push(&#x27;coding&#x27;);</span><br></pre></td></tr></table></figure><p><strong>深拷贝的实现</strong></p><ul><li>1.深拷贝最简单的实现是: JSON.parse(JSON.stringify(obj));</li></ul><blockquote><p>对象的属性值是函数时，无法拷贝。<br>原型链上的属性无法拷贝<br>不能正确的处理 Date 类型的数据<br>不能处理 RegExp<br>会忽略 symbol<br>会忽略 undefined</p></blockquote><ul><li>2.实现一个deepClone函数</li></ul><blockquote><p>如果是基本数据类型，直接返回<br>如果是 RegExp 或者 Date 类型，返回对应类型<br>如果是复杂数据类型，递归。<br>考虑循环引用的问题</p></blockquote><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h3 id=&quot;New的原理&quot;&gt;&lt;a href=&quot;#New的原理&quot; class=&quot;headerlink&quot; title=&quot;New的原理&quot;&gt;&lt;/a&gt;New的原理&lt;/h3&gt;&lt;ul&gt;
&lt;li&gt;1、创建一个空对象，构造函数中的this指向这个空对象&lt;/li&gt;
&lt;li&gt;2、这个新对象被执行[</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>ES6、ES7、ES8、ES9、ES10新特性一览</title>
    <link href="http://yoursite.com/2019/09/29/ES6%E3%80%81ES7%E3%80%81ES8%E3%80%81ES9%E3%80%81ES10%E6%96%B0%E7%89%B9%E6%80%A7%E4%B8%80%E8%A7%88/"/>
    <id>http://yoursite.com/2019/09/29/ES6%E3%80%81ES7%E3%80%81ES8%E3%80%81ES9%E3%80%81ES10%E6%96%B0%E7%89%B9%E6%80%A7%E4%B8%80%E8%A7%88/</id>
    <published>2019-09-29T02:01:03.834Z</published>
    <updated>2019-09-29T03:36:18.347Z</updated>
    
    <content type="html"><![CDATA[<h3 id="ES6新特性（2015）"><a href="#ES6新特性（2015）" class="headerlink" title="ES6新特性（2015）"></a>ES6新特性（2015）</h3><h4 id="类"><a href="#类" class="headerlink" title="类"></a>类</h4> <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line">  class Animal &#123;</span><br><span class="line">   // 构造函数，实例化的时候将会被调用，如果不指定，那么会有一个不带参数的默认构造函数.</span><br><span class="line">   constructor(name,color) &#123;</span><br><span class="line">     this.name = name;</span><br><span class="line">     this.color = color;</span><br><span class="line">   &#125;</span><br><span class="line">   // toString 是原型对象上的属性</span><br><span class="line">   toString() &#123;</span><br><span class="line">     console.log(&#x27;name:&#x27; + this.name + &#x27;,color:&#x27; + this.color);</span><br><span class="line">   &#125;</span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line">var animal = new Animal(&#x27;dog&#x27;,&#x27;white&#x27;);//实例化Animal</span><br><span class="line">animal.toString();</span><br><span class="line"></span><br><span class="line">console.log(animal.hasOwnProperty(&#x27;name&#x27;)); //true</span><br><span class="line">console.log(animal.hasOwnProperty(&#x27;toString&#x27;)); // false</span><br><span class="line">console.log(animal.__proto__.hasOwnProperty(&#x27;toString&#x27;)); // true</span><br><span class="line"></span><br><span class="line">class Cat extends Animal &#123;</span><br><span class="line"> constructor(action) &#123; // catch</span><br><span class="line">   // 子类必须要在constructor中指定super 函数，否则在新建实例的时候会报错.</span><br><span class="line">   // 如果没有置顶consructor,默认带super函数的constructor将会被添加、</span><br><span class="line">   super(&#x27;cat&#x27;,&#x27;white&#x27;);</span><br><span class="line">   this.action = action;</span><br><span class="line"> &#125;</span><br><span class="line"> toString() &#123;</span><br><span class="line">   console.log(super.toString());</span><br><span class="line"> &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">var cat = new Cat(&#x27;catch&#x27;)</span><br><span class="line">cat.toString();</span><br><span class="line"></span><br><span class="line">// 实例cat 是 Cat 和 Animal 的实例，和Es5完全一致。</span><br><span class="line">console.log(cat instanceof Cat); // true</span><br><span class="line">console.log(cat instanceof Animal); // true</span><br></pre></td></tr></table></figure><h4 id="箭头函数"><a href="#箭头函数" class="headerlink" title="箭头函数"></a>箭头函数</h4><blockquote><p>箭头函数的箭头&#x3D;&gt;之前是一个空括号、单个的参数名、或用括号括起的多个参数名，而箭头之后可以是一个表达式（作为函数的返回值），或者是用花括号括起的函数体（需要自行通过return来返回值，否则返回的是undefined）。</p></blockquote> <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"> // 箭头函数的例子</span><br><span class="line">()=&gt;1</span><br><span class="line">v=&gt;v+1</span><br><span class="line">(a,b)=&gt;a+b</span><br><span class="line">()=&gt;&#123;</span><br><span class="line">    alert(&quot;foo&quot;);</span><br><span class="line">&#125;</span><br><span class="line">e=&gt;&#123;</span><br><span class="line">    if (e == 0)&#123;</span><br><span class="line">        return 0;</span><br><span class="line">    &#125;</span><br><span class="line">    return 1000/e;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p> <strong>不论是箭头函数还是bind，每次被执行都返回的是一个新的函数引用，因此如果你还需要函数的引用去做一些别的事情（譬如卸载监听器），那么你必须自己保存这个引用。</strong></p><blockquote><p>正确卸载监听器的做法</p></blockquote><ul><li>方法一 <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"> class PauseMenu extends React.Component&#123;</span><br><span class="line">    constructor(props)&#123;</span><br><span class="line">        super(props);</span><br><span class="line">        this._onAppPaused = this.onAppPaused.bind(this);</span><br><span class="line">    &#125;</span><br><span class="line">    componentWillMount()&#123;</span><br><span class="line">        AppStateIOS.addEventListener(&#x27;change&#x27;, this._onAppPaused);</span><br><span class="line">    &#125;</span><br><span class="line">    componentWillUnmount()&#123;</span><br><span class="line">        AppStateIOS.removeEventListener(&#x27;change&#x27;, this._onAppPaused);</span><br><span class="line">    &#125;</span><br><span class="line">    onAppPaused(event)&#123;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li>方法二</li></ul> <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"> class PauseMenu extends React.Component&#123;</span><br><span class="line">    componentWillMount()&#123;</span><br><span class="line">        AppStateIOS.addEventListener(&#x27;change&#x27;, this.onAppPaused);</span><br><span class="line">    &#125;</span><br><span class="line">    componentWillUnmount()&#123;</span><br><span class="line">        AppStateIOS.removeEventListener(&#x27;change&#x27;, this.onAppPaused);</span><br><span class="line">    &#125;</span><br><span class="line">    onAppPaused = (event) =&gt; &#123;</span><br><span class="line">        //把函数直接作为一个arrow function的属性来定义，初始化的时候就绑定好了this指针</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="解构赋值"><a href="#解构赋值" class="headerlink" title="解构赋值"></a>解构赋值</h4><blockquote><p>如果没有从数组中的获取到值，你可以为变量设置一个默认值。</p></blockquote> <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"> var a, b;</span><br><span class="line"></span><br><span class="line">[a=5, b=7] = [1];</span><br><span class="line">console.log(a); // 1</span><br><span class="line">console.log(b); // 7</span><br></pre></td></tr></table></figure><blockquote><p>通过解构赋值可以方便的交换两个变量的值。</p></blockquote><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">var a = 1;</span><br><span class="line">var b = 3;</span><br><span class="line"></span><br><span class="line">[a, b] = [b, a];</span><br><span class="line">console.log(a); // 3</span><br><span class="line">console.log(b); // 1</span><br></pre></td></tr></table></figure><blockquote><p>获取对象中的值</p></blockquote><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">const student = &#123;</span><br><span class="line">  name:&#x27;Ming&#x27;,</span><br><span class="line">  age:&#x27;18&#x27;,</span><br><span class="line">  city:&#x27;Shanghai&#x27;  </span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">const &#123;name,age,city&#125; = student;</span><br><span class="line">console.log(name); // &quot;Ming&quot;</span><br><span class="line">console.log(age); // &quot;18&quot;</span><br><span class="line">console.log(city); // &quot;Shanghai&quot;</span><br></pre></td></tr></table></figure><blockquote><p>在函数调用时使用延展操作符</p></blockquote><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">function sum(x, y, z) &#123;</span><br><span class="line">  return x + y + z;</span><br><span class="line">&#125;</span><br><span class="line">const numbers = [1, 2, 3];</span><br><span class="line"></span><br><span class="line">//不使用延展操作符</span><br><span class="line">console.log(sum.apply(null, numbers));</span><br><span class="line"></span><br><span class="line">//使用延展操作符</span><br><span class="line">console.log(sum(...numbers));// 6</span><br></pre></td></tr></table></figure><blockquote><p>构造数组</p></blockquote><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">const stuendts = [&#x27;Jine&#x27;,&#x27;Tom&#x27;]; </span><br><span class="line">const persons = [&#x27;Tony&#x27;,... stuendts,&#x27;Aaron&#x27;,&#x27;Anna&#x27;];</span><br><span class="line">conslog.log(persions)// [&quot;Tony&quot;, &quot;Jine&quot;, &quot;Tom&quot;, &quot;Aaron&quot;, &quot;Anna&quot;]</span><br></pre></td></tr></table></figure><blockquote><p>数组拷贝</p></blockquote><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">const stuendts = [&#x27;Jine&#x27;,&#x27;Tom&#x27;]; </span><br><span class="line">const persons = [&#x27;Tony&#x27;,... stuendts,&#x27;Aaron&#x27;,&#x27;Anna&#x27;];</span><br><span class="line">conslog.log(persions) // [&quot;Tony&quot;, &quot;Jine&quot;, &quot;Tom&quot;, &quot;Aaron&quot;, &quot;Anna&quot;]</span><br></pre></td></tr></table></figure><h4 id="Promise"><a href="#Promise" class="headerlink" title="Promise"></a>Promise</h4><blockquote><p>Promise 是异步编程的一种解决方案，比传统的解决方案callback更加的优雅。它最早由社区提出和实现的，ES6 将其写进了语言标准，统一了用法，原生提供了Promise对象。</p></blockquote><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">var waitSecond = new Promise(function(resolve, reject)</span><br><span class="line">&#123;</span><br><span class="line">    setTimeout(resolve, 1000);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">waitSecond</span><br><span class="line">    .then(function()</span><br><span class="line">    &#123;</span><br><span class="line">      console.log(&quot;Hello&quot;); // 1秒后输出&quot;Hello&quot;</span><br><span class="line">      return waitSecond;</span><br><span class="line">    &#125;)</span><br><span class="line">    .then(function()</span><br><span class="line">    &#123;</span><br><span class="line">        console.log(&quot;Hi&quot;); // 2秒后输出&quot;Hi&quot;</span><br><span class="line">    &#125;);</span><br></pre></td></tr></table></figure><h3 id="ES7新特性（2016）"><a href="#ES7新特性（2016）" class="headerlink" title="ES7新特性（2016）"></a>ES7新特性（2016）</h3><ul><li>数组includes()方法，用来判断一个数组是否包含一个指定的值，根据情况，如果包含则返回true，否则返回false。</li></ul><p> <strong>includes</strong> 函数与 <strong>indexOf</strong> 函数很相似，下面两个表达式是等价的：<br> <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"> arr.includes(x)</span><br><span class="line"></span><br><span class="line"> let arr = [&#x27;react&#x27;, &#x27;angular&#x27;, &#x27;vue&#x27;];</span><br><span class="line">if (arr.indexOf(&#x27;react&#x27;) !== -1)</span><br><span class="line">&#123;</span><br><span class="line">    console.log(&#x27;react存在&#x27;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"> arr.indexOf(x) &gt;= 0</span><br><span class="line"></span><br><span class="line"> let arr = [&#x27;react&#x27;, &#x27;angular&#x27;, &#x27;vue&#x27;];</span><br><span class="line">if (arr.includes(&#x27;react&#x27;))</span><br><span class="line">&#123;</span><br><span class="line">    console.log(&#x27;react存在&#x27;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h3 id="ES8新特性（2017）"><a href="#ES8新特性（2017）" class="headerlink" title="ES8新特性（2017）"></a>ES8新特性（2017）</h3><blockquote><p>Object.values()是一个与Object.keys()类似的新函数，但返回的是Object自身属性的所有值，不包括继承的值。</p></blockquote> <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">const obj = &#123;a: 1, b: 2, c: 3&#125;;</span><br></pre></td></tr></table></figure><ul><li>不使用Object.values() :ES7</li></ul> <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">const vals=Object.keys(obj).map(key=&gt;obj[key]);</span><br><span class="line">console.log(vals); //[1, 2, 3]</span><br></pre></td></tr></table></figure><ul><li>使用Object.values() :ES8</li></ul> <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">const values=Object.values(obj1);</span><br><span class="line">console.log(values);//[1, 2, 3]</span><br></pre></td></tr></table></figure><h4 id="Object-entries"><a href="#Object-entries" class="headerlink" title="Object.entries()"></a>Object.entries()</h4><blockquote><p>Object.entries()函数返回一个给定对象自身可枚举属性的键值对的数组。</p></blockquote><ul><li>不使用Object.entries() :ES7</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">Object.keys(obj).forEach(key=&gt;&#123;</span><br><span class="line">console.log(&#x27;key:&#x27;+key+&#x27; value:&#x27;+obj[key]);</span><br><span class="line">&#125;)</span><br><span class="line">//key:a value:1</span><br><span class="line">//key:b value:2</span><br><span class="line">//key:c value:3</span><br></pre></td></tr></table></figure><ul><li>使用Object.entries() :ES8</li></ul> <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"> for(let [key,value] of Object.entries(obj1))&#123;</span><br><span class="line">console.log(`key: $&#123;key&#125; value:$&#123;value&#125;`)</span><br><span class="line">&#125;</span><br><span class="line">//key:a value:1</span><br><span class="line">//key:b value:2</span><br><span class="line">//key:c value:3</span><br></pre></td></tr></table></figure><p> <strong>String.prototype.padStart</strong>和<strong>String.prototype.padEnd</strong></p><blockquote><p>String.padStart(targetLength,[padString])</p></blockquote><ul><li>targetLength:当前字符串需要填充到的目标长度。如果这个数值小于当前字符串的长度，则返回当前字符串本身。</li><li>padString:(可选)填充字符串。如果字符串太长，使填充后的字符串长度超过了目标长度，则只保留最左侧的部分，其他部分会被截断，此参数的缺省值为 “ “。</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">console.log(&#x27;0.0&#x27;.padStart(4,&#x27;10&#x27;)) //10.0</span><br><span class="line">console.log(&#x27;0.0&#x27;.padStart(20)) // 0.00    </span><br></pre></td></tr></table></figure><blockquote><p>String.padEnd(targetLength,padString])</p></blockquote><ul><li>targetLength:当前字符串需要填充到的目标长度。如果这个数值小于当前字符串的长度，则返回当前字符串本身。</li><li>padString:(可选) 填充字符串。如果字符串太长，使填充后的字符串长度超过了目标长度，则只保留最左侧的部分，其他部分会被截断，此参数的缺省值为 “ “；</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">console.log(&#x27;0.0&#x27;.padEnd(4,&#x27;0&#x27;))  //0.00    </span><br><span class="line">console.log(&#x27;0.0&#x27;.padEnd(10,&#x27;0&#x27;)) //0.00000000</span><br></pre></td></tr></table></figure><h3 id="Es-10"><a href="#Es-10" class="headerlink" title="Es 10"></a>Es 10</h3><p> <strong>flat()</strong> 和 <strong>flatMap</strong></p><ul><li>flat()和flatMap()本质上就是是归纳（reduce） 与 合并（concat）的操作。</li><li>数组降维</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">var arr1 = [1, 2, [3, 4]];</span><br><span class="line">arr1.flat(); </span><br><span class="line">// [1, 2, 3, 4]</span><br><span class="line"></span><br><span class="line">var arr2 = [1, 2, [3, 4, [5, 6]]];</span><br><span class="line">arr2.flat();</span><br><span class="line">// [1, 2, 3, 4, [5, 6]]</span><br><span class="line"></span><br><span class="line">var arr3 = [1, 2, [3, 4, [5, 6]]];</span><br><span class="line">arr3.flat(2);</span><br><span class="line">// [1, 2, 3, 4, 5, 6]</span><br><span class="line"></span><br><span class="line">//使用 Infinity 作为深度，展开任意深度的嵌套数组</span><br><span class="line">arr3.flat(Infinity); </span><br><span class="line">// [1, 2, 3, 4, 5, 6]</span><br></pre></td></tr></table></figure><blockquote><p>flat()方法的特性来去除数组的空项</p></blockquote><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">var arr4 = [1, 2, , 4, 5];</span><br><span class="line">arr4.flat();</span><br><span class="line">// [1, 2, 4, 5]</span><br></pre></td></tr></table></figure><p><strong>flatMap()</strong> 方法首先使用映射函数映射每个元素，然后将结果压缩成一个新数组。它与 map 和 深度值1的 flat 几乎相同，但 flatMap 通常在合并成一种方法的效率稍微高一些。 这里我们拿map方法与flatMap方法做一个比较。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">var arr1 = [1, 2, 3, 4];</span><br><span class="line"></span><br><span class="line">arr1.map(x =&gt; [x * 2]); </span><br><span class="line">// [[2], [4], [6], [8]]</span><br><span class="line"></span><br><span class="line">arr1.flatMap(x =&gt; [x * 2]);</span><br><span class="line">// [2, 4, 6, 8]</span><br><span class="line"></span><br><span class="line">// 只会将 flatMap 中的函数返回的数组 “压平” 一层</span><br><span class="line">arr1.flatMap(x =&gt; [[x * 2]]);</span><br><span class="line">// [[2], [4], [6], [8]]</span><br><span class="line"></span><br></pre></td></tr></table></figure><h4 id="Object-fromEntries"><a href="#Object-fromEntries" class="headerlink" title="Object.fromEntries()"></a>Object.fromEntries()</h4><blockquote><p>Object.fromEntries() 方法把键值对列表转换为一个对象。</p></blockquote><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">let obj = &#123; apple : 10, orange : 20, banana : 30 &#125;;</span><br><span class="line">let entries = Object.entries(obj);</span><br><span class="line">entries;</span><br><span class="line">(3) [Array(2), Array(2), Array(2)]</span><br><span class="line"> 0: (2) [&quot;apple&quot;, 10]</span><br><span class="line"> 1: (2) [&quot;orange&quot;, 20]</span><br><span class="line"> 2: (2) [&quot;banana&quot;, 30]</span><br><span class="line">let fromEntries = Object.fromEntries(entries);</span><br><span class="line">&#123; apple: 10, orange: 20, banana: 30 &#125;</span><br></pre></td></tr></table></figure><h4 id="String-trimStart-与-String-trimEnd"><a href="#String-trimStart-与-String-trimEnd" class="headerlink" title="String.trimStart() 与 String.trimEnd()"></a>String.trimStart() 与 String.trimEnd()</h4><blockquote><p>trimStart() ：删除字符串的开头空格。<br>trimEnd() ：删除字符串末尾的空格。</p></blockquote><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">let greeting = &quot;     Space around     &quot;;</span><br><span class="line">greeting.trimEnd();   // &quot;     Space around&quot;;</span><br><span class="line">greeting.trimStart(); // &quot;Space around     &quot;</span><br></pre></td></tr></table></figure><h4 id="Array-prototype-sort"><a href="#Array-prototype-sort" class="headerlink" title="Array.prototype.sort()"></a>Array.prototype.sort()</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">var fruit = [</span><br><span class="line">    &#123; name: &quot;Apple&quot;,      count: 13, &#125;,</span><br><span class="line">    &#123; name: &quot;Pear&quot;,       count: 12, &#125;,</span><br><span class="line">    &#123; name: &quot;Banana&quot;,     count: 12, &#125;,</span><br><span class="line">    &#123; name: &quot;Strawberry&quot;, count: 11, &#125;,</span><br><span class="line">    &#123; name: &quot;Cherry&quot;,     count: 11, &#125;,</span><br><span class="line">    &#123; name: &quot;Blackberry&quot;, count: 10, &#125;,</span><br><span class="line">    &#123; name: &quot;Pineapple&quot;,  count: 10, &#125;</span><br><span class="line">];</span><br><span class="line">// 创建排序函数:</span><br><span class="line">let my_sort = (a, b) =&gt; a.count - b.count;</span><br><span class="line">// 执行稳定的ES10排序:</span><br><span class="line">let sorted = fruit.sort(my_sort);</span><br><span class="line">console.log(sorted);</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h3 id=&quot;ES6新特性（2015）&quot;&gt;&lt;a href=&quot;#ES6新特性（2015）&quot; class=&quot;headerlink&quot; title=&quot;ES6新特性（2015）&quot;&gt;&lt;/a&gt;ES6新特性（2015）&lt;/h3&gt;&lt;h4 id=&quot;类&quot;&gt;&lt;a href=&quot;#类&quot; class=&quot;he</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>Array.from</title>
    <link href="http://yoursite.com/2019/09/18/Array.from/"/>
    <id>http://yoursite.com/2019/09/18/Array.from/</id>
    <published>2019-09-18T03:18:01.281Z</published>
    <updated>2019-09-18T04:05:20.778Z</updated>
    
    <content type="html"><![CDATA[<h3 id="Array-from-介绍"><a href="#Array-from-介绍" class="headerlink" title="Array.from 介绍"></a>Array.from 介绍</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Array.from(arrayLike[, mapFunction[, thisArg]]);</span><br></pre></td></tr></table></figure><blockquote><p>arrayLike：必传参数，想要转换成数组的伪数组对象或可迭代对象。<br>mapFunction：可选参数，mapFunction(item，index){…} 是在集合中的每个项目上调用的函数。返回的值将插入到新集合中。<br>thisArg：可选参数，执行回调函数 mapFunction 时 this 对象。这个参数很少使用。</p></blockquote><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">const someNumbers = &#123; &#x27;0&#x27;: 10, &#x27;1&#x27;: 15, length: 2 &#125;;</span><br><span class="line">Array.from(someNumbers, value =&gt; value * 2);  =&gt; [20, 30]</span><br></pre></td></tr></table></figure><h4 id="将类数组转换成数组"><a href="#将类数组转换成数组" class="headerlink" title="将类数组转换成数组"></a>将类数组转换成数组</h4><p><strong>Array.from()</strong> 第一个用途：将类数组对象转换成数组。</p><ul><li>例子: 函数中的 <strong>arguments</strong> 关键字，或者是一个 <strong>DOM</strong> 集合。</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">function sumArguments() &#123;</span><br><span class="line">    return Array.from(arguments).reduce((sum, num) =&gt; sum + num);</span><br><span class="line">&#125;</span><br><span class="line">sumArguments(1, 2, 3);  =&gt; 6</span><br></pre></td></tr></table></figure><p><strong>Array.from(arguments)</strong> 将类数组对象 <strong>arguments</strong> 转换成一个数组，然后使用数组的 <strong>reduce</strong> 方法求和。</p><blockquote><p>Array.from() 的第一个参数可以是任意一个可迭代对象</p></blockquote><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">Array.from(&#x27;Hey&#x27;);                    =&gt; [&#x27;H&#x27;, &#x27;e&#x27;, &#x27;y&#x27;]</span><br><span class="line">Array.from(new Set([&#x27;one&#x27;, &#x27;two&#x27;]));  =&gt; [&#x27;one&#x27;, &#x27;two&#x27;]</span><br><span class="line"></span><br><span class="line">const map = new Map();</span><br><span class="line">map.set(&#x27;one&#x27;, 1)</span><br><span class="line">map.set(&#x27;two&#x27;, 2);</span><br><span class="line">Array.from(map);  =&gt; [[&#x27;one&#x27;, 1], [&#x27;two&#x27;, 2]]</span><br></pre></td></tr></table></figure><h4 id="克隆一个数组"><a href="#克隆一个数组" class="headerlink" title="克隆一个数组"></a>克隆一个数组</h4><blockquote><p>在 <strong>JavaScript</strong> 中有很多克隆数组的方法。正如你所想，<strong>Array.from()</strong> 可以很容易的实现数组的浅拷贝。</p></blockquote><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">const numbers = [3, 6, 9];</span><br><span class="line">const numbersCopy = Array.from(numbers);</span><br><span class="line">numbers === numbersCopy;  =&gt; false</span><br></pre></td></tr></table></figure><p><strong>Array.from(numbers)</strong> 创建了对 numbers 数组的浅拷贝，numbers &#x3D;&#x3D;&#x3D; numbersCopy 的结果是 <strong>false</strong>，意味着虽然 numbers 和 numbersCopy 有着相同的项，但是它们是不同的数组对象。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">function recursiveClone(val) &#123;</span><br><span class="line">    return Array.isArray(val) ? Array.from(val, recursiveClone) : val;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">const numbers = [[0, 1, 2], [&#x27;one&#x27;, &#x27;two&#x27;, &#x27;three&#x27;]];</span><br><span class="line">const numbersClone = recursiveClone(numbers);</span><br><span class="line"></span><br><span class="line">numbersClone;  =&gt; [[0, 1, 2], [&#x27;one&#x27;, &#x27;two&#x27;, &#x27;three&#x27;]]</span><br><span class="line">numbers[0] === numbersClone[0]  =&gt; false</span><br></pre></td></tr></table></figure><p><strong>recursiveClone()</strong> 能够对数组的深拷贝，通过判断 数组的 <strong>item</strong> 是否是一个数组，如果是数组，就继续调用 <strong>recursiveClone()</strong> 来实现了对数组的深拷贝。</p><h4 id="使用值填充数组"><a href="#使用值填充数组" class="headerlink" title="使用值填充数组"></a>使用值填充数组</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">const length = 3;</span><br><span class="line">const init   = 0;</span><br><span class="line">const result = Array.from(&#123; length &#125;, () =&gt; init);</span><br><span class="line"></span><br><span class="line">result;  =&gt; [0, 0, 0]</span><br></pre></td></tr></table></figure><p><strong>result</strong> 是一个新的数组，它的长度为3，数组的每一项都是0。调用 <strong>Array.from()</strong> 方法，传入一个类数组对象 <strong>{ length }</strong> 和 返回初始化值的 <strong>mapFunction</strong> 函数。</p><blockquote><p>有一个替代方法 <strong>array.fill()</strong> 可以实现同样的功能。</p></blockquote><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">const length = 3;</span><br><span class="line">const init   = 0;</span><br><span class="line">const result = Array(length).fill(init);</span><br><span class="line"></span><br><span class="line">fillArray2(0, 3);  =&gt; [0, 0, 0]</span><br></pre></td></tr></table></figure><h4 id="使用对象填充数组"><a href="#使用对象填充数组" class="headerlink" title="使用对象填充数组"></a>使用对象填充数组</h4><blockquote><p>当初始化数组的每个项都应该是一个新对象时，Array.from() 是一个更好的解决方案：</p></blockquote><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">const length = 3;</span><br><span class="line">const resultA = Array.from(&#123; length &#125;, () =&gt; (&#123;&#125;));</span><br><span class="line">const resultB = Array(length).fill(&#123;&#125;);</span><br><span class="line"></span><br><span class="line">resultA;  =&gt; [&#123;&#125;, &#123;&#125;, &#123;&#125;]</span><br><span class="line">resultB;  =&gt; [&#123;&#125;, &#123;&#125;, &#123;&#125;]</span><br><span class="line"></span><br><span class="line">resultA[0] === resultA[1];  =&gt; false</span><br><span class="line">resultB[0] === resultB[1];  =&gt; true</span><br></pre></td></tr></table></figure><p>由 <strong>Array.from</strong> 返回的 <strong>resultA</strong> 使用不同空对象实例进行初始化。之所以发生这种情况是因为每次调用时，mapFunction，即此处的 <strong>() &#x3D;&gt; ({})</strong> 都会返回一个新的对象。<br>然后，<strong>fill()</strong> 方法创建的 <strong>resultB</strong> 使用相同的空对象实例进行初始化。不会跳过空项。</p><h4 id="数组去重"><a href="#数组去重" class="headerlink" title="数组去重"></a>数组去重</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">function unique(array) &#123;</span><br><span class="line">  return Array.from(new Set(array));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">unique([1, 1, 2, 3, 3]);  =&gt; [1, 2, 3]</span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h3 id=&quot;Array-from-介绍&quot;&gt;&lt;a href=&quot;#Array-from-介绍&quot; class=&quot;headerlink&quot; title=&quot;Array.from 介绍&quot;&gt;&lt;/a&gt;Array.from 介绍&lt;/h3&gt;&lt;figure class=&quot;highlight plai</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>common-Js</title>
    <link href="http://yoursite.com/2019/09/17/common-Js/"/>
    <id>http://yoursite.com/2019/09/17/common-Js/</id>
    <published>2019-09-17T02:02:04.020Z</published>
    <updated>2019-09-17T08:35:00.635Z</updated>
    
    <content type="html"><![CDATA[<h3 id="时间转换"><a href="#时间转换" class="headerlink" title="时间转换"></a>时间转换</h3><ul><li>param date 要格式化的日期，不传时默认当前时间，也可以是一个时间戳</li><li>param fmt 目标字符串格式，支持的字符有：y,M,d,q,w,H,h,m,S，默认：yyyy-MM-dd HH:mm:ss</li><li>@return 返回格式化后的日期字符串</li></ul> <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">formatDate: function (date, fmt) &#123;</span><br><span class="line">      if (!date) &#123;</span><br><span class="line">        return &quot;&quot;;</span><br><span class="line">      &#125;</span><br><span class="line">      date = date == undefined ? new Date() : date;</span><br><span class="line">      date = typeof date == &#x27;number&#x27; ? new Date(date) : date;</span><br><span class="line">      fmt = fmt || &#x27;yyyy-MM-dd HH:mm:ss&#x27;;</span><br><span class="line">      var obj = &#123;</span><br><span class="line">        &#x27;y&#x27;: date.getFullYear(),    年份，注意必须用getFullYear</span><br><span class="line">        &#x27;M&#x27;: date.getMonth() + 1,   月份，注意是从0-11</span><br><span class="line">        &#x27;d&#x27;: date.getDate(),        日期</span><br><span class="line">        &#x27;q&#x27;: Math.floor((date.getMonth() + 3) / 3),  季度</span><br><span class="line">        &#x27;w&#x27;: date.getDay(),         星期，注意是0-6</span><br><span class="line">        &#x27;H&#x27;: date.getHours(),       24小时制</span><br><span class="line">        &#x27;h&#x27;: date.getHours() % 12 == 0 ? 12 : date.getHours() % 12,  12小时制</span><br><span class="line">        &#x27;m&#x27;: date.getMinutes(),     分钟</span><br><span class="line">        &#x27;s&#x27;: date.getSeconds(),     秒</span><br><span class="line">        &#x27;S&#x27;: date.getMilliseconds() 毫秒</span><br><span class="line">      &#125;;</span><br><span class="line">      var week = [&#x27;天&#x27;, &#x27;一&#x27;, &#x27;二&#x27;, &#x27;三&#x27;, &#x27;四&#x27;, &#x27;五&#x27;, &#x27;六&#x27;];</span><br><span class="line">      for (var i in obj) &#123;</span><br><span class="line">        fmt = fmt.replace(new RegExp(i + &#x27;+&#x27;, &#x27;g&#x27;), function (m) &#123;</span><br><span class="line">          var val = obj[i] + &#x27;&#x27;;</span><br><span class="line">          if (i == &#x27;w&#x27;) return (m.length &gt; 2 ? &#x27;星期&#x27; : &#x27;周&#x27;) + week[val];</span><br><span class="line">          for (var j = 0, len = val.length; j &lt; m.length - len; j++) val = &#x27;0&#x27; + val;</span><br><span class="line">          return m.length == 1 ? val : val.substring(val.length - m.length);</span><br><span class="line">        &#125;);</span><br><span class="line">      &#125;</span><br><span class="line">      return fmt;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h3 id="将字符串解析成日期"><a href="#将字符串解析成日期" class="headerlink" title="将字符串解析成日期"></a>将字符串解析成日期</h3><ul><li>@param str 输入的日期字符串，如’2014-09-13’</li><li>@param fmt 字符串格式，默认’yyyy-MM-dd’，支持如下：y、M、d、H、m、s、S，不支持w和q</li><li>@returns 解析后的Date类型日期</li></ul> <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">parseDate: function (str, fmt) &#123;</span><br><span class="line">  fmt = fmt || &#x27;yyyy-MM-dd&#x27;;</span><br><span class="line">  var obj = &#123;</span><br><span class="line">    y: 0,</span><br><span class="line">    M: 1,</span><br><span class="line">    d: 0,</span><br><span class="line">    H: 0,</span><br><span class="line">    h: 0,</span><br><span class="line">    m: 0,</span><br><span class="line">    s: 0,</span><br><span class="line">    S: 0</span><br><span class="line">  &#125;;</span><br><span class="line">  fmt.replace(/([^yMdHmsS]*?)(([yMdHmsS])\3*)([^yMdHmsS]*?)/g, function (m, $1, $2, $3, $4, idx, old) &#123;</span><br><span class="line">    str = str.replace(new RegExp($1 + &#x27;(\\d&#123;&#x27; + $2.length + &#x27;&#125;)&#x27; + $4), function (_m, _$1) &#123;</span><br><span class="line">      obj[$3] = parseInt(_$1);</span><br><span class="line">      return &#x27;&#x27;;</span><br><span class="line">    &#125;);</span><br><span class="line">    return &#x27;&#x27;;</span><br><span class="line">  &#125;);</span><br><span class="line">  obj.M--;  月份是从0开始的，所以要减去1</span><br><span class="line">  var date = new Date(obj.y, obj.M, obj.d, obj.H, obj.m, obj.s);</span><br><span class="line">  if (obj.S !== 0) date.setMilliseconds(obj.S);  如果设置了毫秒</span><br><span class="line">  return date;</span><br><span class="line">&#125;,</span><br></pre></td></tr></table></figure><ul><li>将一个日期格式化成友好格式，比如，1分钟以内的返回“刚刚”，</li><li>当天的返回时分，当年的返回月日，否则，返回年月日</li><li>@param {Object} date</li></ul> <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">formatDateToFriendly: function (date) &#123;</span><br><span class="line">       date = date || new Date();</span><br><span class="line">       date = typeof date === &#x27;number&#x27; ? new Date(date) : date;</span><br><span class="line">       var now = new Date();</span><br><span class="line">       if ((now.getTime() - date.getTime()) &lt; 60 * 1000) return &#x27;刚刚&#x27;; // 1分钟以内视作“刚刚”</span><br><span class="line">       var temp = this.formatDate(date, &#x27;yyyy年M月d&#x27;);</span><br><span class="line">       if (temp == this.formatDate(now, &#x27;yyyy年M月d&#x27;)) return this.formatDate(date, &#x27;HH:mm&#x27;);</span><br><span class="line">       if (date.getFullYear() == now.getFullYear()) return this.formatDate(date, &#x27;M月d日&#x27;);</span><br><span class="line">       return temp;</span><br><span class="line">     &#125;,</span><br></pre></td></tr></table></figure><ul><li>将一段时长转换成友好格式，如：</li><li>147-&gt;“2分27秒”</li><li>1581-&gt;“26分21秒”</li><li>15818-&gt;“4小时24分”</li><li>@param {Object} second</li></ul> <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">formatDurationToFriendly: function (second) &#123;</span><br><span class="line">      if (second &lt; 60) return second + &#x27;秒&#x27;;</span><br><span class="line">      else if (second &lt; 60 * 60) return (second - second % 60) / 60 + &#x27;分&#x27; + second % 60 + &#x27;秒&#x27;;</span><br><span class="line">      else if (second &lt; 60 * 60 * 24) return (second - second % 3600) / 60 / 60 + &#x27;小时&#x27; + Math.round(second % 3600 / 60) + &#x27;分&#x27;;</span><br><span class="line">      return (second / 60 / 60 / 24).toFixed(1) + &#x27;天&#x27;;</span><br><span class="line">    &#125;,</span><br></pre></td></tr></table></figure><ul><li>将时间转换成MM:SS形式</li></ul> <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">formatTimeToFriendly: function (second) &#123;</span><br><span class="line">     var m = Math.floor(second / 60);</span><br><span class="line">     m = m &lt; 10 ? (&#x27;0&#x27; + m) : m;</span><br><span class="line">     var s = second % 60;</span><br><span class="line">     s = s &lt; 10 ? (&#x27;0&#x27; + s) : s;</span><br><span class="line">     return m + &#x27;:&#x27; + s;</span><br><span class="line">   &#125;,</span><br></pre></td></tr></table></figure><h3 id="获取-URL-中的参数"><a href="#获取-URL-中的参数" class="headerlink" title="获取 URL 中的参数"></a>获取 URL 中的参数</h3><ul><li>简单实现</li></ul> <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">var urlParams = new URLSearchParams(&#x27;?post=1234&amp;action=edit&#x27;);</span><br><span class="line">console.log(urlParams.get(&#x27;action&#x27;));  &quot;edit&quot;</span><br></pre></td></tr></table></figure><blockquote><p>有赖于浏览器环境,window.location.search 是浏览器函数<br>意思是:设置或返回从问号 (?) 开始的 URL（查询部分）。</p></blockquote><ul><li>举个例子： <a href="http://xuyuechao.top/?a=3&amp;b=5&amp;c=8888">http://xuyuechao.top?a=3&amp;b=5&amp;c=8888</a><blockquote><p>getUrlParams(‘a’) -&gt; 3<br>getUrlParams(‘b’) -&gt; 5<br>getUrlParams(‘c’) -&gt; 8888</p></blockquote></li></ul> <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">  function getUrlParams(param)&#123;</span><br><span class="line">   有赖于浏览器环境， window.location.search 是浏览器函数</span><br><span class="line">   意思是:设置或返回从问号 (?) 开始的 URL（查询部分）。       </span><br><span class="line">  var query = window.location.search.substring(1);       </span><br><span class="line">  var vars = query.split(&quot;&amp;&quot;);       </span><br><span class="line">  for (var i=0;i&lt;vars.length;i++) &#123;               </span><br><span class="line">    var pair = vars[i].split(&quot;=&quot;);               </span><br><span class="line">    if(pair[0] == param)&#123;return pair[1];&#125;       </span><br><span class="line">  &#125;       </span><br><span class="line">  return(false);</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="手机端判断浏览器类型"><a href="#手机端判断浏览器类型" class="headerlink" title="手机端判断浏览器类型"></a>手机端判断浏览器类型</h3><blockquote><p>目前主要支持 安卓 &amp; 苹果 &amp; ipad &amp; 微信 &amp; 支付宝 &amp; 是否是手机端。</p></blockquote>  <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">  BrowserInfo = &#123;      </span><br><span class="line">  isAndroid: Boolean(navigator.userAgent.match(/android/ig)),      </span><br><span class="line">  isIphone: Boolean(navigator.userAgent.match(/iphone|ipod/ig)),      </span><br><span class="line">  isIpad: Boolean(navigator.userAgent.match(/ipad/ig)),      </span><br><span class="line">  isWeixin: Boolean(navigator.userAgent.match(/MicroMessenger/ig)),      </span><br><span class="line">  isAli: Boolean(navigator.userAgent.match(/AlipayClient/ig)),</span><br><span class="line">  isPhone: Boolean(/(iPhone|iPad|iPod|iOS|Android)/i.test(navigator.userAgent))</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="数组降维"><a href="#数组降维" class="headerlink" title="数组降维"></a>数组降维</h3><ul><li>二维数组</li></ul>  <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">let arr = [ [1], [2], [3] ]</span><br><span class="line">arr = Array.prototype.concat.apply([], arr);  [1, 2, 3]</span><br></pre></td></tr></table></figure><ul><li>多维数组降维<blockquote><p>flat 有兼容性问题，手机端问题不大。浏览器端不兼容 edge。填 Infinity 可展开任意深度的数组<br>flat 默认值为 1。</p>  <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">let arr = [1, 2, [3], [[4]]]</span><br><span class="line">arr = arr.flat(3)  [1, 2, 3, 4] </span><br></pre></td></tr></table></figure></blockquote></li></ul>  <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">flat() 方法会移除数组中的空项:</span><br><span class="line">let arr4 = [1, 2, , 4, 5];</span><br><span class="line">arr4.flat();</span><br><span class="line">[1, 2, 4, 5]</span><br></pre></td></tr></table></figure><ul><li>或者<blockquote><p>反嵌套一层数组</p>  <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">var arr1 = [1, 2, [3, 4]];</span><br><span class="line">arr1.flat();</span><br><span class="line">arr1.reduce((acc, val) =&gt; acc.concat(val), []);// [1, 2, 3, 4]</span><br></pre></td></tr></table></figure><p>或者使用结构赋值</p>  <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">const flatSingle = arr =&gt; [].concat(...arr);</span><br></pre></td></tr></table></figure></blockquote></li></ul><h4 id="深拷贝"><a href="#深拷贝" class="headerlink" title="深拷贝"></a>深拷贝</h4><blockquote><p>使用变量 a 拷贝对象 b，改变 a 中的值 b 中的值也会跟着改变，这叫做浅拷贝。要想让 a 独立于 b 就需要深拷贝</p></blockquote>  <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">function deepClone() &#123;</span><br><span class="line">  return JSON.parse(JSON.stringify(obj))</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>JSON 不支持函数和undefined </p></blockquote><h3 id="防抖和节流"><a href="#防抖和节流" class="headerlink" title="防抖和节流"></a>防抖和节流</h3><ul><li>防抖</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">  function debounce(func, wait) &#123;</span><br><span class="line">    let timeout;</span><br><span class="line">    return function () &#123;</span><br><span class="line">        let context = this;</span><br><span class="line">        let args = arguments;</span><br><span class="line"></span><br><span class="line">        if (timeout) clearTimeout(timeout);</span><br><span class="line">        </span><br><span class="line">        timeout = setTimeout(() =&gt; &#123;</span><br><span class="line">            func.apply(context, args)</span><br><span class="line">        &#125;, wait);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>节流</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">  function throttle(func, wait) &#123;</span><br><span class="line">    let previous = 0;</span><br><span class="line">    return function() &#123;</span><br><span class="line">        let now = Date.now();</span><br><span class="line">        let context = this;</span><br><span class="line">        let args = arguments;</span><br><span class="line">        if (now - previous &gt; wait) &#123;</span><br><span class="line">            func.apply(context, args);</span><br><span class="line">            previous = now;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br></pre></td></tr></table></figure><h3 id="获取数组极值"><a href="#获取数组极值" class="headerlink" title="获取数组极值"></a>获取数组极值</h3>  <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">  function smallest(array)&#123;                           </span><br><span class="line">  return Math.min.apply(Math, array);             </span><br><span class="line">&#125;                                                 </span><br><span class="line">  function largest(array)&#123;                            </span><br><span class="line">  return Math.max.apply(Math, array);             </span><br><span class="line">&#125;  </span><br><span class="line">smallest([0, 1, 2.2, 3.3]);  0</span><br><span class="line">largest([0, 1, 2.2, 3.3]);  3.3</span><br><span class="line"></span><br><span class="line">let list = [1, 2, 3, 4, 5]</span><br><span class="line">Math.max(...list)  5</span><br><span class="line">Math.min(...list)  1</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h3 id=&quot;时间转换&quot;&gt;&lt;a href=&quot;#时间转换&quot; class=&quot;headerlink&quot; title=&quot;时间转换&quot;&gt;&lt;/a&gt;时间转换&lt;/h3&gt;&lt;ul&gt;
&lt;li&gt;param date 要格式化的日期，不传时默认当前时间，也可以是一个时间戳&lt;/li&gt;
&lt;li&gt;param fm</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>微信授权、支付、微信分享相关</title>
    <link href="http://yoursite.com/2019/08/26/WeXin/"/>
    <id>http://yoursite.com/2019/08/26/WeXin/</id>
    <published>2019-08-26T09:35:11.100Z</published>
    <updated>2020-03-07T09:35:50.906Z</updated>
    
    <content type="html"><![CDATA[<h4 id="微信授权"><a href="#微信授权" class="headerlink" title="微信授权"></a>微信授权</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">用户授权 获取code</span><br><span class="line">export function 接口名字(code) &#123;</span><br><span class="line">return http(&#123;</span><br><span class="line">url: 接口地址 + &#x27;?code=&#x27; + code,</span><br><span class="line">method: &#x27;get&#x27;,</span><br><span class="line">data: null</span><br><span class="line">&#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="限制在微信浏览器中打开"><a href="#限制在微信浏览器中打开" class="headerlink" title="限制在微信浏览器中打开"></a>限制在微信浏览器中打开</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">限制用户在微信浏览器中打开</span><br><span class="line">let rediretUrl = &#x27;项目线上地址&#x27;;</span><br><span class="line">    window.location.href = `线上地址/接口地址?后台参数=$&#123;rediretUrl&#125;`;</span><br></pre></td></tr></table></figure><h4 id="微信支付"><a href="#微信支付" class="headerlink" title="微信支付"></a>微信支付</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">安装并引入微信js-sdk</span><br><span class="line">npm install weixin-js-sdk</span><br><span class="line">import wx from &quot;weixin-js-sdk&quot;;</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line">wexinPay(data, cb, errorCb) &#123;</span><br><span class="line">        //获取后台传入的数据</span><br><span class="line">        let appId = data.appId;</span><br><span class="line">        let timestamp = data.timeStamp;</span><br><span class="line">        let nonceStr = data.nonceStr;</span><br><span class="line">        let signature = data.signature;</span><br><span class="line">        let packages = data.package;</span><br><span class="line">        let paySign = data.paySign;</span><br><span class="line">        let signType = data.signType;</span><br><span class="line">        //发起微信支付</span><br><span class="line">        wx.config(&#123;</span><br><span class="line">            debug: false, // 开启调试模式,调用的所有api的返回值会在客户端alert出来，若要查看传入的参数，可以在pc端打开，参数信息会通过log打出，仅在pc端时才会打印。</span><br><span class="line">            appId: appId, // 必填，公众号的唯一标识</span><br><span class="line">            timestamp: timestamp, // 必填，生成签名的时间戳</span><br><span class="line">            nonceStr: nonceStr, // 必填，生成签名的随机串</span><br><span class="line">            signature: signature, // 必填，签名，见附录1</span><br><span class="line">            jsApiList: [&#x27;chooseWXPay&#x27;] // 必填，需要使用的JS接口列表，所有JS接口列表见附录2</span><br><span class="line">        &#125;);</span><br><span class="line">        wx.ready(function () &#123;</span><br><span class="line">            wx.chooseWXPay(&#123;</span><br><span class="line">                timestamp: timestamp, // 支付签名时间戳，注意微信jssdk中的所有使用timestamp字段均为小写。但最新版的支付后台生成签名使用的timeStamp字段名需大写其中的S字符</span><br><span class="line">                nonceStr: nonceStr, // 支付签名随机串，不长于 32 位</span><br><span class="line">                package: packages, // 统一支付接口返回的prepay_id参数值，提交格式如：prepay_id=***）</span><br><span class="line">                signType: signType, // 签名方式，默认为&#x27;SHA1&#x27;，使用新版支付需传入&#x27;MD5&#x27;</span><br><span class="line">                paySign: paySign, // 支付签名</span><br><span class="line">                success: function (res) &#123;</span><br><span class="line">                    // 支付成功后的回调函数</span><br><span class="line">                    cb(res);</span><br><span class="line">                &#125;,</span><br><span class="line">                fail: function (res) &#123;</span><br><span class="line">                    //失败回调函数</span><br><span class="line">                    errorCb(res);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;);</span><br><span class="line">        &#125;);</span><br><span class="line">        wx.error(function (res) &#123;</span><br><span class="line">            // config信息验证失败会执行error函数，如签名过期导致验证失败，具体错误信息可以打开config的debug模式查看，也可以在返回的res参数中查看，对于SPA可以在这里更新签名。</span><br><span class="line">            /*alert(&quot;config信息验证失败&quot;);*/</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line">async 支付接口()&#123;</span><br><span class="line">           let params = &#123;</span><br><span class="line">               &#x27;传入相对应的参数&#x27;</span><br><span class="line">           &#125;</span><br><span class="line">           const response = await 支付接口(params);</span><br><span class="line">           if(&#x27;根据后台返回的判断条件进行判断&#x27;)&#123;</span><br><span class="line">               &#x27;调起微信支付&#x27;</span><br><span class="line">               weixin.wexinPay(</span><br><span class="line">               response.data,</span><br><span class="line">               &#x27;成功回调函数&#x27;</span><br><span class="line">                   res =&gt; &#123;  </span><br><span class="line">                       this.$router.push(&#123;</span><br><span class="line">                           &#x27;调转支付成功页面&#x27;</span><br><span class="line">                           path: &quot;/paySuccess&quot;,</span><br><span class="line">                           &#x27;金额&#x27;</span><br><span class="line">                           query:&#123;</span><br><span class="line">                               price: this.price</span><br><span class="line">                           &#125;</span><br><span class="line">                       &#125;); </span><br><span class="line">                   &#125;,</span><br><span class="line">                   &#x27;取消回调函数&#x27;</span><br><span class="line">                   res =&gt; &#123;  </span><br><span class="line">                       Toast(&#x27;取消支付&#x27;);</span><br><span class="line">                   &#125;,</span><br><span class="line">                   &#x27;失败回调函数&#x27;</span><br><span class="line">                   res =&gt; &#123;  </span><br><span class="line">                       Toast(&#x27;支付失败&#x27;);</span><br><span class="line">                   &#125;,</span><br><span class="line">               )</span><br><span class="line">           &#125;else&#123;</span><br><span class="line">               &#x27;后台返回的错误信息&#x27;</span><br><span class="line">               Toast(response.message);</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;</span><br></pre></td></tr></table></figure><h4 id="微信分享"><a href="#微信分享" class="headerlink" title="微信分享"></a>微信分享</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line">wexinShare: function(data, opstion)&#123;</span><br><span class="line">       wx.config(&#123;</span><br><span class="line">           debug: false, // 开启调试模式,调用的所有api的返回值会在客户端alert出来，若要查看传入的参数，可以在pc端打开，参数信息会通过log打出，仅在pc端时才会打印。</span><br><span class="line">           appId: &#x27;&#x27;, // 必填，公众号的唯一标识</span><br><span class="line">           timestamp: data.timestamp, // 必填，生成签名的时间戳</span><br><span class="line">           nonceStr: data.noncestr, // 必填，生成签名的随机串</span><br><span class="line">           signature: data.signature, // 必填，签名，见附录1</span><br><span class="line">           jsApiList: [</span><br><span class="line">               &#x27;updateAppMessageShareData&#x27;,</span><br><span class="line">               &#x27;updateTimelineShareData&#x27;,</span><br><span class="line">           ] // 必填，需要使用的JS接口列表，所有JS接口列表见附录2</span><br><span class="line">       &#125;);</span><br><span class="line">       wx.ready(function () &#123;</span><br><span class="line">           //分享给朋友</span><br><span class="line">           wx.updateAppMessageShareData(&#123;</span><br><span class="line">               title: opstion.title, // 分享标题</span><br><span class="line">               link: opstion.link, // 分享链接</span><br><span class="line">               imgUrl: opstion.imgUrl, // 分享图标</span><br><span class="line">               desc: opstion.dec, // 分享描述</span><br><span class="line">               success () &#123;</span><br><span class="line">                   opstion.success()</span><br><span class="line">               &#125;,</span><br><span class="line">               cancel () &#123;</span><br><span class="line">                   opstion.error()</span><br><span class="line">               &#125;</span><br><span class="line">           &#125;);</span><br><span class="line">           //分享到朋友圈</span><br><span class="line">           wx.updateTimelineShareData(&#123;</span><br><span class="line">               title: opstion.title, // 分享标题</span><br><span class="line">               link: opstion.link, // 分享链接</span><br><span class="line">               imgUrl: opstion.imgUrl, // 分享图标</span><br><span class="line">               desc: opstion.dec, // 分享描述</span><br><span class="line">               success () &#123;</span><br><span class="line">                   opstion.success()</span><br><span class="line">               &#125;,</span><br><span class="line">               cancel () &#123;</span><br><span class="line">                   opstion.error()</span><br><span class="line">               &#125;</span><br><span class="line">           &#125;)</span><br><span class="line">       &#125;)</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">async 分享接口()&#123;</span><br><span class="line">    &#x27;vue项目，路由没有开启history 模式,也就是你的url上面包含“#”，这个时候要从后端正确获取签名，就需要去掉url上#后面的字符。（url去掉&#x27;#&#x27;hash部分，可用location.href.split(&#x27;#&#x27;)[0]）&#x27;</span><br><span class="line">    let shareUrl = encodeURIComponent(window.location.href.split(&#x27;#&#x27;)[0]);</span><br><span class="line">    let params = &#123;</span><br><span class="line">        strUrl: shareUrl</span><br><span class="line">    &#125;</span><br><span class="line">    let response = await 分享接口(params);</span><br><span class="line">    if (后台判断标识) &#123;</span><br><span class="line">        let opstion = &#123;</span><br><span class="line">            title: this.dubDetail.videoName,</span><br><span class="line">            link: window.location.href,</span><br><span class="line">            imgUrl: this.dubDetail.coverImg,</span><br><span class="line">            dec: this.dubDetail.description,</span><br><span class="line">            success: function () &#123;</span><br><span class="line">                &#x27;此处不需要处理,标语除外&#x27;</span><br><span class="line">            &#125;,</span><br><span class="line">            error: function () &#123;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        weixin.wexinShare(response.data, opstion);</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">        Toast(response.message);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;,</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h4 id=&quot;微信授权&quot;&gt;&lt;a href=&quot;#微信授权&quot; class=&quot;headerlink&quot; title=&quot;微信授权&quot;&gt;&lt;/a&gt;微信授权&lt;/h4&gt;&lt;figure class=&quot;highlight plaintext&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>JavaScript-Array</title>
    <link href="http://yoursite.com/2019/08/01/JavaScript-Array/"/>
    <id>http://yoursite.com/2019/08/01/JavaScript-Array/</id>
    <published>2019-08-01T06:06:06.875Z</published>
    <updated>2019-08-01T10:12:17.848Z</updated>
    
    <content type="html"><![CDATA[<h3 id="JS-数组中的方法"><a href="#JS-数组中的方法" class="headerlink" title="JS 数组中的方法"></a>JS 数组中的方法</h3><h4 id="Array-of"><a href="#Array-of" class="headerlink" title="Array.of()"></a>Array.of()</h4><blockquote><p>‘创建一个具有可变数量参数的新数组实例,不会考虑参数的类型和数量’</p></blockquote><p><strong>Array.of() 和 Array 构造函数之间的区别是</strong></p><blockquote><p>Array.of(7) 创建一个具有单个元素7的数组<br>Array(7) 创建一个长度为7的空数组(这里是指有7个空位(empty)的数组,而不是7个undefined的数组)</p></blockquote><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Array.of(7.0);  [8]</span><br><span class="line">Array(7.0);  [empty × 8]</span><br><span class="line"></span><br></pre></td></tr></table></figure><p><strong>当参数为多个,或者单个参数不是数字时,Array.of 与 Array构造器等同。</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Array.of(8.0, 5);  [8, 5]</span><br><span class="line">Array(8.0, 5);  [8, 5]</span><br><span class="line"></span><br><span class="line">Array.of(&#x27;8&#x27;);  [&quot;8&quot;]</span><br><span class="line">Array(&#x27;8&#x27;);  [&quot;8&quot;]</span><br></pre></td></tr></table></figure><blockquote><p>低版本浏览器不支持,可采用以下方案</p></blockquote><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">if (!Array.of)&#123;</span><br><span class="line">  Array.of = function()&#123;</span><br><span class="line">    return Array.prototype.slice.call(arguments);</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="Array-from"><a href="#Array-from" class="headerlink" title="Array.from"></a>Array.from</h4><blockquote><p>将可以迭代的对象转换成一个新的数组,不改变原对象<br>Array.from 有三个参数()<br>1.想要转换成数组的伪数组对象或可迭代对象<br>2.新数组中的每个元素会执行该回调函数。<br>3.可选参数，执行回调函数 mapFn 时 this 对象。</p></blockquote><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">Array from a String</span><br><span class="line">Array.from(&#x27;foo&#x27;);   </span><br><span class="line">[&quot;f&quot;, &quot;o&quot;, &quot;o&quot;]</span><br><span class="line"></span><br><span class="line">let s = new Set([&#x27;foo&#x27;, window]); </span><br><span class="line">Array.from(s);  </span><br><span class="line">[&quot;foo&quot;, window]</span><br><span class="line"></span><br><span class="line">let m = new Map([[1, 2], [2, 4], [4, 8]]);</span><br><span class="line">Array.from(m);  </span><br><span class="line">[[1, 2], [2, 4], [4, 8]]</span><br><span class="line"></span><br><span class="line">function f() &#123;</span><br><span class="line">  return Array.from(arguments);</span><br><span class="line">&#125;</span><br><span class="line">f(1, 2, 3);</span><br><span class="line"> [1, 2, 3]</span><br><span class="line"></span><br><span class="line"> Array.from([1, 2, 3], x =&gt; x + x);  </span><br><span class="line"> x =&gt; x + x代表这是一个函数，只是省略了其他的定义，这是一种Lambda表达式的写法</span><br><span class="line"> 箭头的意思表示从当前数组中取出一个值，然后自加，并将返回的结果添加到新数组中    </span><br><span class="line"> [2, 4, 6]</span><br><span class="line"></span><br><span class="line"> &#x27;数组中的去重方式&#x27;</span><br><span class="line"></span><br><span class="line"> function combine()&#123; </span><br><span class="line">    let arr = [].concat.apply([], arguments);  没有去重复的新数组 </span><br><span class="line">    return Array.from(new Set(arr));</span><br><span class="line">&#125; </span><br><span class="line"></span><br><span class="line">let m = [1, 2, 2], n = [2,3,3]; </span><br><span class="line">console.log(combine(m,n));                   [1, 2, 3]</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">var obj = &#123;0: &#x27;a&#x27;, 1: &#x27;b&#x27;, 2:&#x27;c&#x27;, length: 3&#125;;</span><br><span class="line">Array.from(obj, function(value, index)&#123;</span><br><span class="line">  console.log(value, index, this, arguments.length);</span><br><span class="line">  return value.repeat(3);  必须指定返回值，否则返回undefined</span><br><span class="line">&#125;, obj);</span><br><span class="line"></span><br></pre></td></tr></table></figure><p><img src="http://louiszhai.github.io/docImages/array01.png" alt="Array.from"><span class="img-alt">Array.from</span></p><blockquote><p>生成一个从0到指定数字的新数组，Array.from就可以轻易的做到。</p></blockquote><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Array.from(&#123;length: 10&#125;, (v, i) =&gt; i);  [0, 1, 2, 3, 4, 5, 6, 7, 8, 9]</span><br></pre></td></tr></table></figure><h4 id="Array-isArray"><a href="#Array-isArray" class="headerlink" title="Array.isArray"></a>Array.isArray</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">let a = [];</span><br><span class="line"> 1.基于instanceof</span><br><span class="line">a instanceof Array;</span><br><span class="line"> 2.基于constructor</span><br><span class="line">a.constructor === Array;</span><br><span class="line"> 3.基于Object.prototype.isPrototypeOf</span><br><span class="line">Array.prototype.isPrototypeOf(a);</span><br><span class="line"> 4.基于getPrototypeOf</span><br><span class="line">Object.getPrototypeOf(a) === Array.prototype;</span><br><span class="line"> 5.基于Object.prototype.toString</span><br><span class="line">Object.prototype.toString.apply(a) === &#x27;[object Array]&#x27;;</span><br><span class="line"></span><br></pre></td></tr></table></figure><blockquote><p>除了Object.prototype.toString外，其它方法都不能正确判断变量的类型。</p></blockquote><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Array.isArray([]);  true</span><br><span class="line">Array.isArray(&#123;0: &#x27;a&#x27;, length: 1&#125;);  false</span><br></pre></td></tr></table></figure><blockquote><p>Array.isArray 实现</p></blockquote><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">if (!Array.isArray)&#123;</span><br><span class="line">  Array.isArray = function(arg)&#123;</span><br><span class="line">    return Object.prototype.toString.call(arg) === &#x27;[object Array]&#x27;;</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="for-of"><a href="#for-of" class="headerlink" title="for of"></a>for of</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">[for (i of [1, 2, 3, 4]) i * i] </span><br><span class="line">[1, 4, 9, 16]</span><br><span class="line"></span><br><span class="line">单个if</span><br><span class="line">[for (i of [1, 2, 3, 4]) if (i == 3) i * i]  [9]</span><br><span class="line"> 甚至是多个if</span><br><span class="line">[for (i of [1, 2, 3, 4]) if (i &gt; 2) if (i &lt; 4) i * i]  [9]</span><br></pre></td></tr></table></figure><h3 id="数组中改变原数组的方法"><a href="#数组中改变原数组的方法" class="headerlink" title="数组中改变原数组的方法:"></a>数组中改变原数组的方法:</h3><h4 id="pop-删除数组的最后一项，并且返回删除的值，原数组发生改变"><a href="#pop-删除数组的最后一项，并且返回删除的值，原数组发生改变" class="headerlink" title="pop() 删除数组的最后一项，并且返回删除的值，原数组发生改变"></a>pop() 删除数组的最后一项，并且返回删除的值，原数组发生改变</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">let array = [&quot;cat&quot;, &quot;dog&quot;, &quot;cow&quot;, &quot;chicken&quot;, &quot;mouse&quot;];</span><br><span class="line">let item = array.pop();</span><br><span class="line">console.log(array);  [&quot;cat&quot;, &quot;dog&quot;, &quot;cow&quot;, &quot;chicken&quot;]</span><br><span class="line">console.log(item);  mouse</span><br></pre></td></tr></table></figure><p><strong>类数组对象上的应用</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">let o = &#123;0:&quot;cat&quot;, 1:&quot;dog&quot;, 2:&quot;cow&quot;, 3:&quot;chicken&quot;, 4:&quot;mouse&quot;, length:5&#125;</span><br><span class="line">let item = Array.prototype.pop.call(o);</span><br><span class="line">console.log(o);  Object &#123;0: &quot;cat&quot;, 1: &quot;dog&quot;, 2: &quot;cow&quot;, 3: &quot;chicken&quot;, length: 4&#125;</span><br><span class="line">console.log(item);  mouse</span><br></pre></td></tr></table></figure><p><strong>pop() 应用到对象上</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">let o = &#123;0:&quot;cat&quot;, 1:&quot;dog&quot;, 2:&quot;cow&quot;, 3:&quot;chicken&quot;, 4:&quot;mouse&quot;&#125;</span><br><span class="line">let item = Array.prototype.pop.call(o);</span><br><span class="line">console.log(o);  Object &#123;0: &quot;cat&quot;, 1: &quot;dog&quot;, 2: &quot;cow&quot;, 3: &quot;chicken&quot;, 4: &quot;mouse&quot;, length: 0&#125;</span><br><span class="line">console.log(item);  undefined</span><br></pre></td></tr></table></figure><h4 id="push-方法添加一个或者多个元素到数组末尾，并且返回数组新的长度"><a href="#push-方法添加一个或者多个元素到数组末尾，并且返回数组新的长度" class="headerlink" title="push()方法添加一个或者多个元素到数组末尾，并且返回数组新的长度"></a>push()方法添加一个或者多个元素到数组末尾，并且返回数组新的长度</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">let array = [&quot;football&quot;, &quot;basketball&quot;, &quot;volleyball&quot;, &quot;Table tennis&quot;, &quot;badminton&quot;];</span><br><span class="line">let i = array.push(&quot;golfball&quot;);</span><br><span class="line">console.log(array);  [&quot;football&quot;, &quot;basketball&quot;, &quot;volleyball&quot;, &quot;Table tennis&quot;, &quot;badminton&quot;, &quot;golfball&quot;]</span><br><span class="line">console.log(i);  6</span><br></pre></td></tr></table></figure><p><strong>push方法也可以应用到对象上</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">let o = &#123;0:&quot;football&quot;, 1:&quot;basketball&quot;&#125;;</span><br><span class="line">let i = Array.prototype.push.call(o, &quot;golfball&quot;);</span><br><span class="line">console.log(o);  Object &#123;0: &quot;golfball&quot;, 1: &quot;basketball&quot;, length: 1&#125;</span><br><span class="line">console.log(i);  1</span><br></pre></td></tr></table></figure><h4 id="shift-方法从数组中删除第一个元素，并返回该元素的值。此方法更改数组的长度。"><a href="#shift-方法从数组中删除第一个元素，并返回该元素的值。此方法更改数组的长度。" class="headerlink" title="shift() 方法从数组中删除第一个元素，并返回该元素的值。此方法更改数组的长度。"></a>shift() 方法从数组中删除第一个元素，并返回该元素的值。此方法更改数组的长度。</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">let array1 = [1, 2, 3];</span><br><span class="line">let firstElement = array1.shift();</span><br><span class="line">console.log(array1);</span><br><span class="line"> expected output: Array [2, 3]</span><br><span class="line"></span><br><span class="line">console.log(firstElement);</span><br><span class="line"> expected output: 1</span><br></pre></td></tr></table></figure><p><strong>对于类数组对象</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">let o = &#123;0:&quot;a&quot;, 1:&quot;b&quot;, 2:&quot;c&quot;, length:3&#125;;</span><br><span class="line">let item = Array.prototype.shift.call(o);</span><br><span class="line">console.log(o);  Object &#123;0: &quot;b&quot;, 1: &quot;c&quot;, length: 2&#125;</span><br><span class="line">console.log(item);  a</span><br></pre></td></tr></table></figure><p><strong>如果类数组对象length属性不存在</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">let o = &#123;0:&quot;a&quot;, 1:&quot;b&quot;, 2:&quot;c&quot;&#125;;</span><br><span class="line">let item = Array.prototype.shift.call(o);</span><br><span class="line">console.log(o);  Object &#123;0: &quot;a&quot;, 1: &quot;b&quot;, 2:&quot;c&quot; length: 0&#125;</span><br><span class="line">console.log(item);  undefined</span><br></pre></td></tr></table></figure><h4 id="unshift-方法将一个或多个元素添加到数组的开头，并返回该数组的新长度-该方法修改原有数组-。"><a href="#unshift-方法将一个或多个元素添加到数组的开头，并返回该数组的新长度-该方法修改原有数组-。" class="headerlink" title="unshift() 方法将一个或多个元素添加到数组的开头，并返回该数组的新长度(该方法修改原有数组)。"></a>unshift() 方法将一个或多个元素添加到数组的开头，并返回该数组的新长度(该方法修改原有数组)。</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">let array1 = [1, 2, 3];</span><br><span class="line">console.log(array1.unshift(4, 5));</span><br><span class="line">expected output: 5</span><br><span class="line">console.log(array1);</span><br><span class="line">expected output: Array [4, 5, 1, 2, 3]</span><br></pre></td></tr></table></figure><h4 id="unshift方法传入一个数组"><a href="#unshift方法传入一个数组" class="headerlink" title="unshift方法传入一个数组"></a>unshift方法传入一个数组</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">let array = [&quot;red&quot;, &quot;green&quot;, &quot;blue&quot;];</span><br><span class="line">let length = array.unshift([&quot;yellow&quot;]);</span><br><span class="line">console.log(array); // [[&quot;yellow&quot;], &quot;red&quot;, &quot;green&quot;, &quot;blue&quot;]</span><br><span class="line">console.log(length); // 4, 可见数组也能成功插入</span><br></pre></td></tr></table></figure><h4 id="类数组的处理方式"><a href="#类数组的处理方式" class="headerlink" title="类数组的处理方式"></a>类数组的处理方式</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">let o = &#123;0:&quot;red&quot;, 1:&quot;green&quot;, 2:&quot;blue&quot;,length:3&#125;;</span><br><span class="line">let length = Array.prototype.unshift.call(o,&quot;gray&quot;);</span><br><span class="line">console.log(o); // Object &#123;0: &quot;gray&quot;, 1: &quot;red&quot;, 2: &quot;green&quot;, 3: &quot;blue&quot;, length: 4&#125;</span><br><span class="line">console.log(length); // 4</span><br></pre></td></tr></table></figure><h4 id="reverse-倒序"><a href="#reverse-倒序" class="headerlink" title="reverse 倒序"></a>reverse 倒序</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">let array = [1,2,3,4,5];</span><br><span class="line">let array2 = array.reverse();</span><br><span class="line"></span><br><span class="line">console.log(array);  [5,4,3,2,1]</span><br><span class="line">console.log(array2===array);  true</span><br></pre></td></tr></table></figure><h4 id="sort-方法对数组元素进行排序，并返回这个数组"><a href="#sort-方法对数组元素进行排序，并返回这个数组" class="headerlink" title="sort()方法对数组元素进行排序，并返回这个数组"></a>sort()方法对数组元素进行排序，并返回这个数组</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">function compare(a, b)&#123;</span><br><span class="line">  return a-b;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="splice-arr-splice-start-deleteCount-item1-item2-…"><a href="#splice-arr-splice-start-deleteCount-item1-item2-…" class="headerlink" title="splice*() arr.splice(start,deleteCount[, item1[, item2[, …]]])"></a>splice*() arr.splice(start,deleteCount[, item1[, item2[, …]]])</h4><blockquote><p>start 起始位置<br>deleteCount 删除个数<br>item 向数组添加的新数值<br>splice() 方法会直接对数组进行修改。<br>返回值:修改后的新数组,原数组发生改变</p></blockquote><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">let array = [&quot;apple&quot;,&quot;boy&quot;];</span><br><span class="line">let splices = array.splice(1,1);</span><br><span class="line">console.log(array); // [&quot;apple&quot;]</span><br><span class="line">console.log(splices); // [&quot;boy&quot;] ,可见是从数组下标为1的元素开始删除,并且删除一个元素,由于itemN缺省,故此时该方法只删除元素</span><br><span class="line"></span><br><span class="line">array = [&quot;apple&quot;,&quot;boy&quot;];</span><br><span class="line">splices = array.splice(2,1,&quot;cat&quot;);</span><br><span class="line">console.log(array); // [&quot;apple&quot;, &quot;boy&quot;, &quot;cat&quot;]</span><br><span class="line">console.log(splices); // [], 可见由于start超过数组长度,此时从数组末尾开始添加元素,并且原数组不会发生删除行为</span><br><span class="line"></span><br><span class="line">array = [&quot;apple&quot;,&quot;boy&quot;];</span><br><span class="line">splices = array.splice(-2,1,&quot;cat&quot;);</span><br><span class="line">console.log(array); // [&quot;cat&quot;, &quot;boy&quot;]</span><br><span class="line">console.log(splices); // [&quot;apple&quot;], 可见当start为负值时,是从数组末尾开始的第-start位开始删除,删除一个元素,并且从此处插入了一个元素</span><br><span class="line"></span><br><span class="line">array = [&quot;apple&quot;,&quot;boy&quot;];</span><br><span class="line">splices = array.splice(-3,1,&quot;cat&quot;);</span><br><span class="line">console.log(array); // [&quot;cat&quot;, &quot;boy&quot;]</span><br><span class="line">console.log(splices); // [&quot;apple&quot;], 可见即使-start超出数组长度,数组默认从首位开始删除</span><br><span class="line"></span><br><span class="line">array = [&quot;apple&quot;,&quot;boy&quot;];</span><br><span class="line">splices = array.splice(0,3,&quot;cat&quot;);</span><br><span class="line">console.log(array); // [&quot;cat&quot;]</span><br><span class="line">console.log(splices); // [&quot;apple&quot;, &quot;boy&quot;], 可见当deleteCount大于数组start之后的元素总和时,start及之后的元素都将被删除</span><br><span class="line"></span><br></pre></td></tr></table></figure><h4 id="类数组中的使用"><a href="#类数组中的使用" class="headerlink" title="类数组中的使用"></a>类数组中的使用</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">let o = &#123;0:&quot;apple&quot;,1:&quot;boy&quot;,length:2&#125;;</span><br><span class="line">let splices = Array.prototype.splice.call(o,1,1);</span><br><span class="line">console.log(o);  Object &#123;0: &quot;apple&quot;, length: 1&#125;, 可见对象o删除了一个属性,并且length-1</span><br><span class="line">console.log(splices);  [&quot;boy&quot;]</span><br></pre></td></tr></table></figure><h3 id="不会改变原数组的方法-9个"><a href="#不会改变原数组的方法-9个" class="headerlink" title="不会改变原数组的方法(9个)"></a>不会改变原数组的方法(9个)</h3><blockquote><p>concat、join、slice、toString、toLocateString、indexOf、lastIndexOf、toSource、includes</p></blockquote><h4 id="concat-方法将传入的数组或者元素与原数组合并，组成一个新的数组并返回"><a href="#concat-方法将传入的数组或者元素与原数组合并，组成一个新的数组并返回" class="headerlink" title="concat() 方法将传入的数组或者元素与原数组合并，组成一个新的数组并返回"></a>concat() 方法将传入的数组或者元素与原数组合并，组成一个新的数组并返回</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">let array = [1, 2, 3];</span><br><span class="line">let array2 = array.concat(4,[5,6],[7,8,9]);</span><br><span class="line">console.log(array2);  [1, 2, 3, 4, 5, 6, 7, 8, 9]</span><br><span class="line">console.log(array);  [1, 2, 3], </span><br></pre></td></tr></table></figure><h4 id="若concat方法中不传入参数，那么将基于原数组浅复制生成一个一模一样的新数组（指向新的地址空间）。"><a href="#若concat方法中不传入参数，那么将基于原数组浅复制生成一个一模一样的新数组（指向新的地址空间）。" class="headerlink" title="若concat方法中不传入参数，那么将基于原数组浅复制生成一个一模一样的新数组（指向新的地址空间）。"></a>若concat方法中不传入参数，那么将基于原数组<strong>浅复制</strong>生成一个一模一样的新数组（指向新的地址空间）。</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">let array = [&#123;a: 1&#125;];</span><br><span class="line">let array3 = array.concat();</span><br><span class="line">console.log(array3);  [&#123;a: 1&#125;]</span><br><span class="line">console.log(array3 === array);  false</span><br><span class="line">console.log(array[0] === array3[0]);  true，新旧数组第一个元素依旧共用一个同一个对象的引用</span><br></pre></td></tr></table></figure><h3 id="join-方法将数组中的所有元素连接成一个字符串。"><a href="#join-方法将数组中的所有元素连接成一个字符串。" class="headerlink" title="join() 方法将数组中的所有元素连接成一个字符串。"></a>join() 方法将数组中的所有元素连接成一个字符串。</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">let array = [&#x27;We&#x27;, &#x27;are&#x27;, &#x27;Chinese&#x27;];</span><br><span class="line">console.log(array.join());  &quot;We,are,Chinese&quot;</span><br><span class="line">console.log(array.join(&#x27;+&#x27;));  &quot;We+are+Chinese&quot;</span><br><span class="line">console.log(array.join(&#x27;&#x27;));  &quot;WeareChinese&quot;</span><br></pre></td></tr></table></figure><h4 id="类数组的操作"><a href="#类数组的操作" class="headerlink" title="类数组的操作"></a>类数组的操作</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">let o = &#123;0:&quot;We&quot;, 1:&quot;are&quot;, 2:&quot;Chinese&quot;, length:3&#125;;</span><br><span class="line">console.log(Array.prototype.join.call(o,&#x27;+&#x27;)); &quot;We+are+Chinese&quot;</span><br><span class="line">console.log(Array.prototype.join.call(&#x27;abc&#x27;));  &quot;a,b,c&quot;</span><br></pre></td></tr></table></figure><h3 id="slice-方法将数组中一部分元素浅复制存入新的数组对象，并且返回这个数组对象。"><a href="#slice-方法将数组中一部分元素浅复制存入新的数组对象，并且返回这个数组对象。" class="headerlink" title="slice() 方法将数组中一部分元素浅复制存入新的数组对象，并且返回这个数组对象。"></a>slice() 方法将数组中一部分元素浅复制存入新的数组对象，并且返回这个数组对象。</h3><blockquote><p>arr.slice([start[, end]])<br>start 指定复制开始位置的索引<br>end如果有值则表示复制结束位置的索引（不包括此位置）<br>start为负数 原数组中的倒数第start个元素到最后一个元素（包含最后一个元素）<br>slice方法参数为空时，同concat方法一样，都是浅复制生成一个新数组。</p></blockquote><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">let array = [&quot;one&quot;, &quot;two&quot;, &quot;three&quot;,&quot;four&quot;, &quot;five&quot;];</span><br><span class="line">console.log(array.slice());  [&quot;one&quot;, &quot;two&quot;, &quot;three&quot;,&quot;four&quot;, &quot;five&quot;]</span><br><span class="line">console.log(array.slice(2,3));  [&quot;three&quot;]</span><br></pre></td></tr></table></figure><h4 id="浅复制-是指当对象的被复制时，只是复制了对象的引用，指向的依然是同一个对象"><a href="#浅复制-是指当对象的被复制时，只是复制了对象的引用，指向的依然是同一个对象" class="headerlink" title="浅复制 是指当对象的被复制时，只是复制了对象的引用，指向的依然是同一个对象"></a>浅复制 是指当对象的被复制时，只是复制了对象的引用，指向的依然是同一个对象</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">let array = [&#123;color:&quot;yellow&quot;&#125;, 2, 3];</span><br><span class="line">let array2 = array.slice(0,1);</span><br><span class="line">console.log(array2);  [&#123;color:&quot;yellow&quot;&#125;]</span><br><span class="line">array[0][&quot;color&quot;] = &quot;blue&quot;;</span><br><span class="line">console.log(array2);  [&#123;color:&quot;bule&quot;&#125;]</span><br></pre></td></tr></table></figure><p><strong>slice是浅复制，复制到的对象是个引用，改变原数组array的值，array2也随之改变。</strong></p><p><strong>数组的最后一项元素</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">console.log([1,2,3].slice(-1)); [3]</span><br></pre></td></tr></table></figure><h4 id="类数组中的尝试"><a href="#类数组中的尝试" class="headerlink" title="类数组中的尝试"></a>类数组中的尝试</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">let o = &#123;0:&#123;&quot;color&quot;:&quot;yellow&quot;&#125;, 1:2, 2:3, length:3&#125;;</span><br><span class="line">let o2 = Array.prototype.slice.call(o,0,1);</span><br><span class="line">console.log(o2); [&#123;color:&quot;yellow&quot;&#125;]</span><br></pre></td></tr></table></figure><h3 id="toString-返回值经调用-join-方法连接（由逗号隔开）组成-返回数组的字符串形式"><a href="#toString-返回值经调用-join-方法连接（由逗号隔开）组成-返回数组的字符串形式" class="headerlink" title="toString() 返回值经调用 join() 方法连接（由逗号隔开）组成,返回数组的字符串形式"></a>toString() 返回值经调用 join() 方法连接（由逗号隔开）组成,返回数组的字符串形式</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">let array = [&#x27;Jan&#x27;, &#x27;Feb&#x27;, &#x27;Mar&#x27;, &#x27;Apr&#x27;];</span><br><span class="line">let str = array.toString();</span><br><span class="line">console.log(str);  Jan,Feb,Mar,Apr</span><br></pre></td></tr></table></figure><h3 id="indexOf-方法用于查找元素在数组中第一次出现时的索引，如果没有，则返回-1"><a href="#indexOf-方法用于查找元素在数组中第一次出现时的索引，如果没有，则返回-1" class="headerlink" title="indexOf() 方法用于查找元素在数组中第一次出现时的索引，如果没有，则返回-1"></a>indexOf() 方法用于查找元素在数组中第一次出现时的索引，如果没有，则返回-1</h3><blockquote><p>Index 为开始查找的位置，缺省默认为0。如果超出数组长度，则返回-1。如果为负值，假设数组长度为length，则从数组的第 length + Index项开始往数组末尾查找，如果length + Index&lt;0 则整个数组都会被查找。</p></blockquote><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">indexOf使用严格相等（即使用 === 去匹配数组中的元素）。</span><br><span class="line">let array = [&#x27;abc&#x27;, &#x27;def&#x27;, &#x27;ghi&#x27;,&#x27;123&#x27;];</span><br><span class="line">console.log(array.indexOf(&#x27;def&#x27;));  1</span><br><span class="line">console.log(array.indexOf(&#x27;def&#x27;,-1));  -1 此时表示从最后一个元素往后查找,因此查找失败返回-1</span><br><span class="line">console.log(array.indexOf(&#x27;def&#x27;,-4));  1 由于4大于数组长度,此时将查找整个数组,因此返回1</span><br><span class="line">console.log(array.indexOf(123));  -1, 由于是严格匹配,因此并不会匹配到字符串&#x27;123&#x27;</span><br></pre></td></tr></table></figure><h4 id="indexOf-可以处理类数组对象"><a href="#indexOf-可以处理类数组对象" class="headerlink" title="indexOf 可以处理类数组对象"></a>indexOf 可以处理类数组对象</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">let o = &#123;0:&#x27;abc&#x27;, 1:&#x27;def&#x27;, 2:&#x27;ghi&#x27;, length:3&#125;;</span><br><span class="line">console.log(Array.prototype.indexOf.call(o,&#x27;ghi&#x27;,-4));</span><br></pre></td></tr></table></figure><h3 id="lastIndexOf-方法用于查找元素在数组中最后一次出现时的索引，如果没有，则返回-1"><a href="#lastIndexOf-方法用于查找元素在数组中最后一次出现时的索引，如果没有，则返回-1" class="headerlink" title="lastIndexOf() 方法用于查找元素在数组中最后一次出现时的索引，如果没有，则返回-1"></a>lastIndexOf() 方法用于查找元素在数组中最后一次出现时的索引，如果没有，则返回-1</h3><h3 id="includes-ES7-用来判断当前数组是否包含某个指定的值，如果是，则返回-true，否则返回-false。"><a href="#includes-ES7-用来判断当前数组是否包含某个指定的值，如果是，则返回-true，否则返回-false。" class="headerlink" title="includes(ES7) 用来判断当前数组是否包含某个指定的值，如果是，则返回 true，否则返回 false。"></a>includes(ES7) 用来判断当前数组是否包含某个指定的值，如果是，则返回 true，否则返回 false。</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">let array = [-0, 1, 2];</span><br><span class="line">console.log(array.includes(+0));  true</span><br><span class="line">console.log(array.includes(1));  true</span><br><span class="line">console.log(array.includes(2,-4));  true</span><br></pre></td></tr></table></figure><p><strong>唯一的区别就是includes能够发现NaN，而indexOf不能。</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">let array = [NaN];</span><br><span class="line">console.log(array.includes(NaN));  true</span><br><span class="line">console.log(arra.indexOf(NaN)&gt;-1);  false</span><br></pre></td></tr></table></figure><h4 id="类数组中使用"><a href="#类数组中使用" class="headerlink" title="类数组中使用"></a>类数组中使用</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">let o = &#123;0:&#x27;a&#x27;, 1:&#x27;b&#x27;, 2:&#x27;c&#x27;, length:3&#125;;</span><br><span class="line">let bool = Array.prototype.includes.call(o, &#x27;a&#x27;);</span><br><span class="line">console.log(bool);  true</span><br></pre></td></tr></table></figure><h3 id="遍历方法（12个）"><a href="#遍历方法（12个）" class="headerlink" title="遍历方法（12个）"></a>遍历方法（12个）</h3><blockquote><p>基于ES6，不会改变自身的方法一共有12个，分别为forEach、every、some、filter、map、reduce、reduceRight 以及ES6新增的方法entries、find、findIndex、keys、values。</p></blockquote><h4 id="forEach-方法指定数组的每项元素都执行一次传入的函数，返回值为undefined。"><a href="#forEach-方法指定数组的每项元素都执行一次传入的函数，返回值为undefined。" class="headerlink" title="forEach() 方法指定数组的每项元素都执行一次传入的函数，返回值为undefined。"></a>forEach() 方法指定数组的每项元素都执行一次传入的函数，返回值为undefined。</h4><blockquote><p>fn 表示在数组每一项上执行的函数，接受三个参数：</p></blockquote><ul><li>value 当前正在被处理的元素的值</li><li>index 当前元素的数组索引</li><li>array 数组本身</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">let array = [1, 3, 5];</span><br><span class="line">let obj = &#123;name:&#x27;cc&#x27;&#125;;</span><br><span class="line">let sReturn = array.forEach(function(value, index, array)&#123;</span><br><span class="line">  array[index] = value * value;</span><br><span class="line">  console.log(this.name);  cc被打印了三次</span><br><span class="line">&#125;,obj);</span><br><span class="line">console.log(array);  [1, 9, 25], 可见原数组改变了</span><br><span class="line">console.log(sReturn);  undefined, 可见返回值为undefined</span><br></pre></td></tr></table></figure><h4 id="类数组的使用"><a href="#类数组的使用" class="headerlink" title="类数组的使用"></a>类数组的使用</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">let o = &#123;0:1, 1:3, 2:5, length:3&#125;;</span><br><span class="line">Array.prototype.forEach.call(o,function(value, index, obj)&#123;</span><br><span class="line">  console.log(value,index,obj);</span><br><span class="line">  obj[index] = value * value;</span><br><span class="line">&#125;,o);</span><br><span class="line"> 1 0 Object &#123;0: 1, 1: 3, 2: 5, length: 3&#125;</span><br><span class="line"> 3 1 Object &#123;0: 1, 1: 3, 2: 5, length: 3&#125;</span><br><span class="line"> 5 2 Object &#123;0: 1, 1: 9, 2: 5, length: 3&#125;</span><br><span class="line">console.log(o);  Object &#123;0: 1, 1: 9, 2: 25, length: 3&#125;</span><br></pre></td></tr></table></figure><p><strong>forEach无法直接退出循环，只能使用return 来达到for循环中continue的效果，并且forEach不能在低版本IE（6~8）中使用</strong></p><h3 id="every-方法用于检验数组中的每一项是否符合某个条件-若符合则放回true-反之则返回false"><a href="#every-方法用于检验数组中的每一项是否符合某个条件-若符合则放回true-反之则返回false" class="headerlink" title="every() 方法用于检验数组中的每一项是否符合某个条件, 若符合则放回true, 反之则返回false."></a>every() 方法用于检验数组中的每一项是否符合某个条件, 若符合则放回true, 反之则返回false.</h3><h4 id="类数组的引用"><a href="#类数组的引用" class="headerlink" title="类数组的引用"></a>类数组的引用</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">let o = &#123;0:10, 1:8, 2:25, length:3&#125;;</span><br><span class="line">let bool = Array.prototype.every.call(o,function(value, index, obj)&#123;</span><br><span class="line">  return value &gt;= 8;</span><br><span class="line">&#125;,o);</span><br><span class="line"></span><br><span class="line">console.log(bool);  true</span><br><span class="line"></span><br><span class="line">[12, 5, 8, 130, 44].every(elem =&gt; elem &gt;= 10);</span><br></pre></td></tr></table></figure><h4 id="every-一样不能在低版本IE-6-8-中使用"><a href="#every-一样不能在低版本IE-6-8-中使用" class="headerlink" title="every 一样不能在低版本IE(6~8)中使用"></a>every 一样不能在低版本IE(6~8)中使用</h4><h3 id="some-方法用于检验数组中的每一项是否符合某个条件-若符合则放回false-反之则返回true"><a href="#some-方法用于检验数组中的每一项是否符合某个条件-若符合则放回false-反之则返回true" class="headerlink" title="some() 方法用于检验数组中的每一项是否符合某个条件, 若符合则放回false., 反之则返回true"></a>some() 方法用于检验数组中的每一项是否符合某个条件, 若符合则放回false., 反之则返回true</h3><h3 id="filter-方法使用传入的函数测试所有元素，并返回所有通过测试的元素组成的新数组。它就好比一个过滤器，筛掉不符合条件的元素。"><a href="#filter-方法使用传入的函数测试所有元素，并返回所有通过测试的元素组成的新数组。它就好比一个过滤器，筛掉不符合条件的元素。" class="headerlink" title="filter() 方法使用传入的函数测试所有元素，并返回所有通过测试的元素组成的新数组。它就好比一个过滤器，筛掉不符合条件的元素。"></a>filter() 方法使用传入的函数测试所有元素，并返回所有通过测试的元素组成的新数组。它就好比一个过滤器，筛掉不符合条件的元素。</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">let array = [18, 9, 10, 35, 80];</span><br><span class="line">let array2 = array.filter(function(value, index, array)&#123;</span><br><span class="line">  return value &gt; 20;</span><br><span class="line">&#125;);</span><br><span class="line">console.log(array2);  [35, 80]</span><br></pre></td></tr></table></figure><p><strong>支持类数组写法</strong></p><h3 id="map-方法遍历数组，使用传入函数处理每个元素，并返回函数的返回值组成的新数组。-支持类数组写法"><a href="#map-方法遍历数组，使用传入函数处理每个元素，并返回函数的返回值组成的新数组。-支持类数组写法" class="headerlink" title="map() 方法遍历数组，使用传入函数处理每个元素，并返回函数的返回值组成的新数组。 支持类数组写法"></a>map() 方法遍历数组，使用传入函数处理每个元素，并返回函数的返回值组成的新数组。 支持类数组写法</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">let array = [1, 4, 9];</span><br><span class="line">let roots = array.map(Math.sqrt);//map包裹方法名</span><br><span class="line"> roots is now [1, 2, 3], array is still [1, 4, 9]</span><br><span class="line">let array = [1, 4, 9];</span><br><span class="line">let doubles = array.map(function(num) &#123;  map包裹方法实体</span><br><span class="line">  return num * 2;</span><br><span class="line">&#125;);</span><br><span class="line"> doubles is now [2, 8, 18]. array is still [1, 4, 9]</span><br></pre></td></tr></table></figure><h4 id="map-支持类数组-例如-NodeList"><a href="#map-支持类数组-例如-NodeList" class="headerlink" title="map 支持类数组 例如 NodeList"></a>map 支持类数组 例如 NodeList</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">let elems = document.querySelectorAll(&#x27;select option:checked&#x27;);</span><br><span class="line">let values = Array.prototype.map.call(elems, function(obj) &#123;</span><br><span class="line">  return obj.value;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><h4 id="map-处理字符串"><a href="#map-处理字符串" class="headerlink" title="map 处理字符串"></a>map 处理字符串</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">var map = Array.prototype.map;</span><br><span class="line">var array = map.call(&#x27;Hello 中国&#x27;, function(x) &#123; </span><br><span class="line">  return x.charCodeAt(0);</span><br><span class="line">&#125;);</span><br><span class="line">console.log(array);</span><br><span class="line">[72, 101, 108, 108, 111, 32, 20013, 22269]</span><br></pre></td></tr></table></figure><h4 id="将字符串数组转换为数字数组"><a href="#将字符串数组转换为数字数组" class="headerlink" title="将字符串数组转换为数字数组"></a>将字符串数组转换为数字数组</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">console.log([&#x27;1&#x27;, &#x27;2&#x27;, &#x27;3&#x27;].map(Number)); [1,2,3]</span><br></pre></td></tr></table></figure><h4 id="reduce-方法接收一个方法作为累加器，数组中的每个值-从左至右-开始合并，最终为一个值。-支持类数组写法"><a href="#reduce-方法接收一个方法作为累加器，数组中的每个值-从左至右-开始合并，最终为一个值。-支持类数组写法" class="headerlink" title="reduce() 方法接收一个方法作为累加器，数组中的每个值(从左至右) 开始合并，最终为一个值。 支持类数组写法"></a>reduce() 方法接收一个方法作为累加器，数组中的每个值(从左至右) 开始合并，最终为一个值。 支持类数组写法</h4><blockquote><p>previousValue 上一次调用回调返回的值，或者是提供的初始值<br>value 数组中当前被处理元素的值<br>index 当前元素在数组中的索引<br>array 数组自身</p></blockquote><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">var array = [1, 2, 3, 4];</span><br><span class="line">array.reduce((p, v) =&gt; p * v);  24</span><br></pre></td></tr></table></figure><h3 id="reduceRight-方法接收一个方法作为累加器，数组中的每个值（从右至左）开始合并，最终为一个值"><a href="#reduceRight-方法接收一个方法作为累加器，数组中的每个值（从右至左）开始合并，最终为一个值" class="headerlink" title="reduceRight() 方法接收一个方法作为累加器，数组中的每个值（从右至左）开始合并，最终为一个值"></a>reduceRight() 方法接收一个方法作为累加器，数组中的每个值（从右至左）开始合并，最终为一个值</h3><h3 id="find-返回数组中第一个满足条件的元素（如果有的话）-1，-如果没有，则返回undefined。-支持类数组写法"><a href="#find-返回数组中第一个满足条件的元素（如果有的话）-1，-如果没有，则返回undefined。-支持类数组写法" class="headerlink" title="find() 返回数组中第一个满足条件的元素（如果有的话）-1， 如果没有，则返回undefined。 支持类数组写法"></a>find() 返回数组中第一个满足条件的元素（如果有的话）-1， 如果没有，则返回undefined。 支持类数组写法</h3><h3 id="findIndex-它返回数组中第一个满足条件的元素的索引（如果有的话）否则返回-1。支持类数组写法"><a href="#findIndex-它返回数组中第一个满足条件的元素的索引（如果有的话）否则返回-1。支持类数组写法" class="headerlink" title="findIndex() 它返回数组中第一个满足条件的元素的索引（如果有的话）否则返回-1。支持类数组写法"></a>findIndex() 它返回数组中第一个满足条件的元素的索引（如果有的话）否则返回-1。支持类数组写法</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">var array = [1, 3, 5, 7, 8, 9, 10];</span><br><span class="line">function f(value, index, array)&#123;</span><br><span class="line">  return value%2==0;  返回偶数</span><br><span class="line">&#125;</span><br><span class="line">function f2(value, index, array)&#123;</span><br><span class="line">  return value &gt; 20;  返回大于20的数</span><br><span class="line">&#125;</span><br><span class="line">console.log(array.find(f));  8</span><br><span class="line">console.log(array.find(f2));  undefined</span><br><span class="line">console.log(array.findIndex(f));  4</span><br><span class="line">console.log(array.findIndex(f2));  -1</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h3 id=&quot;JS-数组中的方法&quot;&gt;&lt;a href=&quot;#JS-数组中的方法&quot; class=&quot;headerlink&quot; title=&quot;JS 数组中的方法&quot;&gt;&lt;/a&gt;JS 数组中的方法&lt;/h3&gt;&lt;h4 id=&quot;Array-of&quot;&gt;&lt;a href=&quot;#Array-of&quot; class=&quot;</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>JavaScript-this call、apply、bind</title>
    <link href="http://yoursite.com/2019/07/17/JavaScript-this%20call%E3%80%81apply%E3%80%81bind/"/>
    <id>http://yoursite.com/2019/07/17/JavaScript-this%20call%E3%80%81apply%E3%80%81bind/</id>
    <published>2019-07-17T15:52:44.093Z</published>
    <updated>2019-07-17T17:30:34.852Z</updated>
    
    <content type="html"><![CDATA[<h3 id="this指向"><a href="#this指向" class="headerlink" title="this指向"></a>this指向</h3><p><strong>this永远指向最后调用他的那个对象</strong></p><blockquote><p>一个函数执行前面没有调用他的对象 <strong>this指向的window</strong><br>匿名函数 自执行函数 函数当参数 <strong>默认指向window</strong><br>函数是否在 new中调用 xxx &#x3D; new xxx <strong>this指向的实例</strong><br>元素事件中绑定函数的this是 <strong>绑定的元素</strong></p></blockquote><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">&#x27;虽然将a.fn赋值给了变量f,但是没有调用，所以fn()最后仍然是被 window 调用的。</span><br><span class="line">所以 this 指向的也就是 window&#x27; </span><br><span class="line">var name = &quot;windowsName&quot;;</span><br><span class="line">var a = &#123;</span><br><span class="line">    name : null,</span><br><span class="line">    fn : function () &#123;</span><br><span class="line">        console.log(this.name); &#x27;windowsName&#x27;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">var f = a.fn;</span><br><span class="line">&#x27;变量f == fn这个函数本身&#x27;</span><br><span class="line">f();</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">var a=1</span><br><span class="line">var obj=&#123;</span><br><span class="line">a:2,</span><br><span class="line">getA:function()&#123;return this.a&#125;</span><br><span class="line">&#125;</span><br><span class="line">console.log(obj.getA());  &#x27;2 (this=&gt;obj)&#x27;</span><br><span class="line">console.log(obj.getA.call());  &#x27;1 (this=&gt;window)&#x27;</span><br><span class="line">console.log(obj.getA.call(&#123;a:10&#125;));  &#x27;10 (this=&gt;&#123;a:10&#125;) window&#x27;</span><br></pre></td></tr></table></figure><p><strong>箭头函数中的this</strong></p><ul><li>箭头函数中的没有this指向,也没有arguments</li><li>箭头函数中的this始终指向 <strong>函数定义</strong> 时的this</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">var name = &quot;windowsName&quot;;</span><br><span class="line">var a = &#123;</span><br><span class="line">    name : &quot;Cherry&quot;,</span><br><span class="line">    func1: function () &#123;</span><br><span class="line">        console.log(this.name)     </span><br><span class="line">    &#125;,</span><br><span class="line">    func2: function () &#123;</span><br><span class="line">        setTimeout( () =&gt; &#123;</span><br><span class="line">            this.func1()</span><br><span class="line">        &#125;,100);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line">a.func2()</span><br></pre></td></tr></table></figure><h3 id="call-apply-bind"><a href="#call-apply-bind" class="headerlink" title="call apply bind"></a>call apply bind</h3><ul><li>相同点第一个参数都是改变this指向,第一个参数为null&#x2F;undefined&#x2F;为空,默认指向的window<blockquote><p>call 可以接收一个参数列表<br>apply接收的是一个类数组<br>bind需要执行一个()并且返回一个新的函数</p></blockquote></li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">&#x27;call&#x27;</span><br><span class="line">    var a = &#123;</span><br><span class="line">        name : &quot;Cherry&quot;,</span><br><span class="line">        func1: function () &#123;</span><br><span class="line">            console.log(this.name)</span><br><span class="line">        &#125;,</span><br><span class="line">        func2: function () &#123;</span><br><span class="line">            setTimeout(  function () &#123;</span><br><span class="line">                this.func1()</span><br><span class="line">            &#125;.call(a),100);  &#x27;apply(同理)&#x27;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line">    a.func2()   &#x27;Cherry&#x27;</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">&#x27;bind 是创建一个新函数,需要执行一下&#x27;</span><br><span class="line">    var a =&#123;</span><br><span class="line">        name : &quot;Cherry&quot;,</span><br><span class="line">        fn : function (a,b) &#123;</span><br><span class="line">            console.log( a + b)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    var b = a.fn;</span><br><span class="line">    b.bind(a,1,2)() &#x27;3&#x27;</span><br><span class="line"></span><br><span class="line">&#x27;bind 方法实现&#x27;</span><br><span class="line"> Function.prototype.bind = function(context,...arg)&#123;</span><br><span class="line">     return ()=&gt;&#123;this.apply(context,arg)&#125;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure><h3 id="new-构造函数"><a href="#new-构造函数" class="headerlink" title="new 构造函数"></a>new 构造函数</h3><ul><li>函数调用前使用了new关键字,调用了构造函数,看似创建了新的函数,实际上是函数重新创建了对象</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">function myFunction(arg1, arg2) &#123;</span><br><span class="line">    this.firstName = arg1;</span><br><span class="line">    this.lastName  = arg2;</span><br><span class="line">&#125;</span><br><span class="line">&#x27;This    creates a new object&#x27;</span><br><span class="line">var a = new myFunction(&quot;Li&quot;,&quot;Cherry&quot;);</span><br><span class="line">a.lastName;</span><br></pre></td></tr></table></figure><h3 id="new-的原理"><a href="#new-的原理" class="headerlink" title="new 的原理"></a>new 的原理</h3><ul><li>创建一个新的对象</li><li>这个新对象会被执行[原型]连接</li><li>属性和方法都会加入到<strong>this</strong>引用的对象中,并执行构造函数中的方法</li><li>如果函数中没有返回其他对象，那么this就指向了这个新对象<br>否则this就指向了构造函数中返回的对象</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">&#x27;var obj = new fn()&#x27;</span><br><span class="line">function new(fn)&#123;</span><br><span class="line">    let obj = &#123;&#125;;</span><br><span class="line">    obj.__propo__ = fn.propotype;</span><br><span class="line">    let res = fn.call(obj);</span><br><span class="line">    if (typeof(res)==&#x27;object&#x27; || typeof(res)== &#x27;function&#x27;)&#123;</span><br><span class="line">        return res</span><br><span class="line">    &#125;</span><br><span class="line">    return obj;</span><br><span class="line">&#125;</span><br><span class="line">&#x27;例子&#x27;:</span><br><span class="line">function Student(name, num, age) &#123;</span><br><span class="line">            this.name = name;</span><br><span class="line">            this.num = num;</span><br><span class="line">            this.age = age;</span><br><span class="line">            let obj = &#123;man:&#x27;男&#x27;&#125;;</span><br><span class="line">            &#x27;否则this指向构造函数中返回的对象&#x27;</span><br><span class="line">            return obj;</span><br><span class="line">        &#125;</span><br><span class="line">        &#x27;如果函数没有返回其他对象，那么this指向这个新对象 == s2&#x27;</span><br><span class="line">        var s2 = new Student(&quot;xiaoming&quot;, 54321, 18)</span><br><span class="line">        console.log(s2);</span><br></pre></td></tr></table></figure><h3 id="通过new的方式创建对象和通过字面量创建有什么区别？"><a href="#通过new的方式创建对象和通过字面量创建有什么区别？" class="headerlink" title="通过new的方式创建对象和通过字面量创建有什么区别？"></a>通过new的方式创建对象和通过字面量创建有什么区别？</h3><blockquote><p>字面量创建方式,简介且性能好<br>通过new的方式创建对象、本质上的方法是调用，其实是通过propo进行查找<br>查找过程中必将调用必须的堆栈信息,方法调用后(释放堆栈),造成一定的性能损耗</p></blockquote>]]></content>
    
    
      
      
    <summary type="html">&lt;h3 id=&quot;this指向&quot;&gt;&lt;a href=&quot;#this指向&quot; class=&quot;headerlink&quot; title=&quot;this指向&quot;&gt;&lt;/a&gt;this指向&lt;/h3&gt;&lt;p&gt;&lt;strong&gt;this永远指向最后调用他的那个对象&lt;/strong&gt;&lt;/p&gt;
&lt;blockquote&gt;
&lt;</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>JavaScript-prototype</title>
    <link href="http://yoursite.com/2019/07/16/JavaScript-prototype/"/>
    <id>http://yoursite.com/2019/07/16/JavaScript-prototype/</id>
    <published>2019-07-16T15:39:01.010Z</published>
    <updated>2019-07-16T16:26:24.411Z</updated>
    
    <content type="html"><![CDATA[<h3 id="基于原型的理解"><a href="#基于原型的理解" class="headerlink" title="基于原型的理解"></a>基于原型的理解</h3><p> <strong>每个函数天生都自带一个属性prototype,这个属性是个对象</strong><br> <strong>这个对象储存了当前类提供给实例的公共属性和方法，浏览器默认给他开辟一个堆内存</strong><br> <strong>prototype都有一个默认属性，construction指向当前函数本身</strong><br> <strong>每个对象都有一个__propo__这个属性，这个属性指向的是当前所属类的prototype</strong><br> <strong>如何不确定是谁的实例，那就是Object的实例</strong></p><h3 id="原型链"><a href="#原型链" class="headerlink" title="原型链"></a>原型链</h3><p> <strong>原型链是基于__propo__向上查找的机制，当我们去操作实例的某个属性和方法的时候，首先查找自己的空间下有没有这个属性，如果有的话就用自己的，如果没有的话就通过__propo__机制向上查找所属类的prototype，如果找到就用找到的，如果没有找到则依次查找，一直找到Object.prototype为止，如果还没有找到，则返回undefined</strong></p> <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Object.__proto__  === Function.prototype;</span><br><span class="line">Function.prototype.__proto__ === Object.prototype;</span><br><span class="line">Object.prototype.__proto__ === null;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p> <strong>实例于与构造函数的关系图</strong></p><p> <img src="https://user-gold-cdn.xitu.io/2019/4/8/169fc27e0cf46ee9?imageView2/0/w/1280/h/960/format/webp/ignore-error/1" alt="实例与构造函数"><span class="img-alt">实例与构造函数</span></p><p> <strong>prototype与propo的关系</strong></p><blockquote><p>propo 是每个实例都有的属性，指向的当前类所属的原型<br>实例的 propo 与其构造函数中的 prototype 指向的同一个对象</p></blockquote> <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">function Student(name) &#123;</span><br><span class="line">    this.name = name;</span><br><span class="line">&#125;</span><br><span class="line">Student.prototype.setAge = function ()&#123;</span><br><span class="line">    this.age=20;</span><br><span class="line">&#125;</span><br><span class="line">let Jack = new Student(&#x27;jack&#x27;);</span><br><span class="line">console.log(Jack.__proto__);</span><br><span class="line">console.log(Student.prototype);</span><br><span class="line">console.log(Jack.__proto__ instanceof Student.prototype); &#x27;true&#x27;</span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h3 id=&quot;基于原型的理解&quot;&gt;&lt;a href=&quot;#基于原型的理解&quot; class=&quot;headerlink&quot; title=&quot;基于原型的理解&quot;&gt;&lt;/a&gt;基于原型的理解&lt;/h3&gt;&lt;p&gt; &lt;strong&gt;每个函数天生都自带一个属性prototype,这个属性是个对象&lt;/strong&gt;&lt;</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>JavaScript-变量提升</title>
    <link href="http://yoursite.com/2019/07/16/JavaScript-%E5%8F%98%E9%87%8F%E6%8F%90%E5%8D%87/"/>
    <id>http://yoursite.com/2019/07/16/JavaScript-%E5%8F%98%E9%87%8F%E6%8F%90%E5%8D%87/</id>
    <published>2019-07-15T16:09:03.477Z</published>
    <updated>2019-07-16T15:37:25.537Z</updated>
    
    <content type="html"><![CDATA[<h4 id="let-var-const"><a href="#let-var-const" class="headerlink" title="let var const"></a>let var const</h4><p> <strong>let const两者都没有变量提升,而var存在变量提升</strong><br> <strong>let const 存在块级作用域</strong><br> <strong>两者都不存在重复声明,const一旦声明必须赋值，一旦赋值不能更改</strong><br> <strong>let 和 const如果提前声明，会报错（暂时性死区）</strong></p><h4 id="js中的变量提升"><a href="#js中的变量提升" class="headerlink" title="js中的变量提升"></a>js中的变量提升</h4><p> <strong>变量提升就是:在变量提升之前使用了该变量，结果是undefined</strong></p><blockquote><p>当作用域形成之后,浏览器会把带var(声明)，function(声明并定义)关键字的进行声明和定义<br>声明：var a&#x2F;function sum() 默认值是undefined 定义：就是赋值<br>变量提升只存在于当前作用域，当页面刚加载时会对全局作用域下的变量进行变量提升，函数中存储的都是字符串<br>浏览器很懒，当代码执行遇到创建函数，变量声明这个阶段时，直接回跳过(变量提升过程中已完成)</p></blockquote><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">&#x27;test函数内部有变量申明var a;会提升到函数作用域的最前面</span><br><span class="line">全局没有变量a,所以结果是undefined而不会报错&#x27;</span><br><span class="line">   function test()&#123;</span><br><span class="line">        if(&#x27;a&#x27; in window)&#123;</span><br><span class="line">            var a = 10;</span><br><span class="line">        &#125;</span><br><span class="line">        console.log(a); </span><br><span class="line">    &#125;</span><br><span class="line">    test();</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"> &#x27;这里foo为undefined,所以!foo结果为true;&#x27;</span><br><span class="line">var foo = 1;</span><br><span class="line">function bar() &#123;</span><br><span class="line">    if(!foo)</span><br><span class="line">    &#123;</span><br><span class="line">        var foo = 10;</span><br><span class="line">    &#125;</span><br><span class="line">    console.log(foo); </span><br><span class="line">&#125;</span><br><span class="line">bar(); &#x27;10&#x27;</span><br><span class="line"></span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">  &#x27;变量提升a和b为undefined,虽然为undefined但是存在于window上,取反为false&#x27;</span><br><span class="line"> var a=1</span><br><span class="line">if (!(b in window)) &#123;</span><br><span class="line">    var b=2;</span><br><span class="line">    a+=1; </span><br><span class="line">&#125;else&#123;</span><br><span class="line">    a+=2</span><br><span class="line">&#125;</span><br><span class="line">console.log(a); &#x27;3&#x27;</span><br><span class="line">console.log(b); &#x27;undefined&#x27;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h4 id="js中暂时性死区？"><a href="#js中暂时性死区？" class="headerlink" title="js中暂时性死区？"></a>js中暂时性死区？</h4><p>暂时性死区的本质:当进入作用域时，所需要的变量已经存在，但是不可获取<br>只有等到声明的那一行代码出现，才可以获取和使用该变量。</p><p><em>闭包及其优点:</em></p><p>简单理解: <strong>闭包就是能够读取其他函数中变量的函数</strong></p><blockquote><p>保护函数中的私有变量不受外界变量的干扰<br>实现了js的模块化<br>模仿块级作用域(Es5不存在块级作用域)<br>缺点：大量使用闭包，会造成性能消耗</p></blockquote><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">函数A中包含了函数B,函数B中使用了函数A的变量,&#x27;函数B则是闭包&#x27;</span><br><span class="line">function A()&#123;</span><br><span class="line">    let a = 1;</span><br><span class="line">    function B()&#123;</span><br><span class="line">        console.log(a)</span><br><span class="line">    &#125;</span><br><span class="line">    return B()</span><br><span class="line">&#125;</span><br><span class="line">A()</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>面试题</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&#x27;利用let的块级作用域，让每一次的值形成唯一&#x27;</span><br><span class="line">for ( let i=0; i&lt;=5; i++) &#123;</span><br><span class="line">setTimeout( function timer() &#123;</span><br><span class="line">console.log( i );</span><br><span class="line">&#125;, i*1000 );</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&#x27;利用定时器的第二个参数&#x27;</span><br><span class="line">for ( var i=0; i&lt;=5; i++) &#123;</span><br><span class="line">setTimeout( function timer(i) &#123;</span><br><span class="line">console.log( i );</span><br><span class="line">&#125;, i*1000,i);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&#x27;利用闭包&#x27;</span><br><span class="line">for ( var i=0; i&lt;=5; i++) &#123;</span><br><span class="line">(function(i)&#123;</span><br><span class="line">        setTimeout( ()=&gt;&#123;</span><br><span class="line">console.log( i );</span><br><span class="line">&#125;,i*1000);</span><br><span class="line">    &#125;)(i)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h4 id=&quot;let-var-const&quot;&gt;&lt;a href=&quot;#let-var-const&quot; class=&quot;headerlink&quot; title=&quot;let var const&quot;&gt;&lt;/a&gt;let var const&lt;/h4&gt;&lt;p&gt; &lt;strong&gt;let const两者都没有变量提</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>Html-css</title>
    <link href="http://yoursite.com/2019/07/14/html-Css/"/>
    <id>http://yoursite.com/2019/07/14/html-Css/</id>
    <published>2019-07-14T14:58:12.373Z</published>
    <updated>2019-07-14T15:48:04.126Z</updated>
    
    <content type="html"><![CDATA[<h3 id="HTML"><a href="#HTML" class="headerlink" title="HTML"></a>HTML</h3><h4 id="1-什么是标签语义化及其优点"><a href="#1-什么是标签语义化及其优点" class="headerlink" title="1.什么是标签语义化及其优点"></a>1.什么是标签语义化及其优点</h4><p>合理的标签做合理的事情<br><strong>优点:</strong></p><p>便于浏览器、搜索引擎的解析<br>便于阅读源代码的人对网站进行维护和理解<br>在没有css的情况下，页面的内容结构和代码结构更加美观</p><h4 id="2-H5中的新标签"><a href="#2-H5中的新标签" class="headerlink" title="2.H5中的新标签"></a>2.H5中的新标签</h4><p>1 <header>头部</header> <footer>尾部</footer><br>2 <nav>导航</nav> <cavas>动画</cavas><br>3 <audio>音频</audio> <video>视频</video></p><h4 id="3-本地存储方式"><a href="#3-本地存储方式" class="headerlink" title="3.本地存储方式"></a>3.本地存储方式</h4><p><strong>cookies: 存储浏览器端的数据，可以设置cookie的到期时间,如果不设置时间,则在浏览器关闭时关闭</strong><br><strong>session: 存储服务端的数据,session存储特定的用户回话所需要的属性和配置信息</strong></p><p><strong>两者的区别:</strong></p><blockquote><p>cookies 存储于浏览器端的数据，sessions存储于服务端的数据<br>cookies 安全性较低，cookies存储的信息为4k<br>session存储重要信息,如果sessions存储的信息过大，会占用服务器的性能</p></blockquote><p><strong>localStoage 本地存储方式 (永久) 除非主动清除,否则一直存在</strong><br><strong>sessionStorage 本地存储方式 (临时) 浏览器窗口关闭,则失效</strong></p><blockquote><p>1.localStoage.getItem(‘name’) ‘获取’ name 的值<br>2.localStoage.setItem(‘name’) ‘设置’ name 的值<br>3.localStoage.removeItem(‘name’) ‘删除’ name 的值</p></blockquote><h4 id="CSS"><a href="#CSS" class="headerlink" title="CSS"></a>CSS</h4><p><strong>css 盒模型</strong></p><p>box-sizing:border-box<br>box-sezing:content-box<br><strong>两者的区别:</strong></p><p>  1 border-box: 整个盒子的宽、高、包括 ‘margin’ ‘padding’ ‘border’<br>  2 content-box: 整个盒子的宽、高、’不包含’上面的元素</p><p><img src="https://user-gold-cdn.xitu.io/2019/3/17/1698bdd0101065ad?imageView2/0/w/1280/h/960/format/webp/ignore-error/1" alt="css 盒模型"><span class="img-alt">css 盒模型</span></p><p><strong>css 常用选择器</strong></p><blockquote><p>1.通配符：*<br>2.ID 选择器：#ID<br>3.类选择器：.class<br>4.元素选择器：p、a 等……<br>5.后代选择器：p span、div a 等……<br>6.伪类选择器：a:hover 等……<br>7.属性选择器：input[type&#x3D;”text”] 等……<br>8.子元素选择器：li:firth-child、p:nth-child(1)</p></blockquote><p><strong>css 选择器的权重</strong></p><p><em><strong>1 ‘!important -&gt; 行内样式 -&gt; #id -&gt; .class -&gt; 元素和伪元素 -&gt; * -&gt; 继承 -&gt; 默认’</strong></em></p><p><strong>css 新特性</strong></p><blockquote><p>1.transition：过渡<br>2.transform：旋转、缩放、移动或者倾斜<br>3.animation：动画<br>4.gradient：渐变<br>5.shadow：阴影<br>6.border-radius：圆角<br>7.css 引入方式以及优先级</p></blockquote><p><em><strong>在引用 CSS 上，分为四种形式：行内样式、内嵌式、链接式以及导入式</strong></em></p><p><em><strong>在优先级上,行内样式 &gt; 链接式 &gt; 内嵌式 &gt; @import 导入式。</strong></em></p><p><strong>less 与 sass stylus 的区别</strong></p><p><em><strong>变量声明 :</strong></em></p><blockquote><p>1.Sass声明变量方式 $ 开头, 后面紧跟着变量值和变量名,变量名和变量值需要使用冒号:分隔开<br>2.Less 声明变量方式 @ 开头, 其余等同于Sass<br>3.stylus 变量声明没有任何限定,结尾分号可有可无, 变量名和变量值中间必须用 &#x3D; 等号</p></blockquote><p><strong>作用域</strong></p><blockquote><p>Sass 作用域最差,不存在全局变量的概念, 注意相同的变量名字<br>Less 近期更新, 可以定义全局变量<br>与 Sass 相同,变量值输出是根据最近声明的一次定义,每次引用最近的定义</p></blockquote><p><strong>嵌套</strong></p><p><em><strong>三种都有设计嵌套关系,使用上没有任何区别,引用父级选择器的标记 &amp; 也相同</strong></em></p><p><strong>继承</strong></p><p><em><strong>Sass 和 Stylus 相似,能把一个选择器上的内容继承到另一个选择器上,使用『@extend』开始,后面接被继承的选择器</strong></em></p><p><strong>导入 import</strong></p><blockquote><p>‘Sass 中只存在使用 url() 表达式 引入式进行变量插值’<br>$device: mobile;<br>@import url(styles.#{$device}.css);</p></blockquote><blockquote><p>‘Less 可以在字符串中插值’<br>@device: mobile;<br>@import “styles.@{device}.css”;</p></blockquote><p><em><strong>‘Stylus 只能利用字符串拼接实现’</strong></em></p><blockquote><p>device &#x3D; “mobile”<br>@import “styles.” + device + “.css”<br>Sass 和 less 语法相对于严谨,Stylus相对于自由,less表现方式更像是css,上手比较容易<br>Sass 和 stylus 具有逻辑处理方式 例如: 条件&#x2F;循环 less需要通过when进行处理</p></blockquote>]]></content>
    
    
      
      
    <summary type="html">&lt;h3 id=&quot;HTML&quot;&gt;&lt;a href=&quot;#HTML&quot; class=&quot;headerlink&quot; title=&quot;HTML&quot;&gt;&lt;/a&gt;HTML&lt;/h3&gt;&lt;h4 id=&quot;1-什么是标签语义化及其优点&quot;&gt;&lt;a href=&quot;#1-什么是标签语义化及其优点&quot; class=&quot;headerli</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>Hello World</title>
    <link href="http://yoursite.com/2019/07/13/hello-world/"/>
    <id>http://yoursite.com/2019/07/13/hello-world/</id>
    <published>2019-07-13T13:10:09.898Z</published>
    <updated>2019-07-13T13:10:09.898Z</updated>
    
    <content type="html"><![CDATA[<p>Welcome to <a href="https://hexo.io/">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues">GitHub</a>.</p><h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo new <span class="string">&quot;My New Post&quot;</span></span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/writing.html">Writing</a></p><h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/server.html">Server</a></p><h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/generating.html">Generating</a></p><h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/deployment.html">Deployment</a></p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;Welcome to &lt;a href=&quot;https://hexo.io/&quot;&gt;Hexo&lt;/a&gt;! This is your very first post. Check &lt;a href=&quot;https://hexo.io/docs/&quot;&gt;documentation&lt;/a&gt; for</summary>
      
    
    
    
    
  </entry>
  
</feed>
